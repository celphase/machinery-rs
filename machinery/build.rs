use std::{fs, path::Path};

use heck::CamelCase;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{GenericArgument, Item, ItemStruct, PathArguments, Type, TypeBareFn};

fn main() {
    let out_path = Path::new("./src/generated/foundation.rs");

    // Only generate if the file doesn't exist already
    //if out_path.exists() {
    //return;
    //}

    // Load the input file
    let input = fs::read_to_string("../machinery-sys/src/foundation.rs").unwrap();
    let file = syn::parse_file(&input).unwrap();

    let mut src = String::new();
    src.push_str("// Code generated by machinery's build.rs\n\n");
    src.push_str("use unsafe_unwrap::UnsafeUnwrap;\n");
    src.push_str("use machinery_sys::foundation::*;\n\n");

    for item in file.items {
        if let Item::Struct(item) = item {
            let name = item.ident.to_string();

            // Skip anything that isn't an API
            if !name.ends_with("_api") {
                continue;
            }

            generate_api(&mut src, item);
        }
    }

    fs::write(out_path, src).unwrap();
}

fn generate_api(src: &mut String, item: ItemStruct) {
    let raw_name = item.ident;
    let name = raw_name.to_string()[3..].to_camel_case();

    src.push_str(&format!("pub struct {}(pub *const {});\n\n", name, raw_name));
    src.push_str(&format!("impl {} {{\n", name));

    // Associated name
    src.push_str(&format!(
        "    pub const NAME: &'static str = \"{}\";\n\n",
        raw_name,
    ));

    for field in item.fields {
        let path_type = if let Type::Path(path_type) = field.ty {
            path_type
        } else {
            continue;
        };

        // Extract the type
        let segment = path_type.path.segments.last().unwrap();
        if segment.ident != "Option" {
            // Skip non-options, they're not what we're looking for
            continue;
        }

        let arguments = if let PathArguments::AngleBracketed(ref arguments) = segment.arguments {
            arguments
        } else {
            continue;
        };

        let type_arg = if let GenericArgument::Type(ref type_arg) = arguments.args[0] {
            type_arg
        } else {
            continue;
        };

        let fn_type = if let Type::BareFn(fn_type) = type_arg {
            fn_type
        } else {
            continue;
        };

        // Convert the parameters
        let (in_args, conversions, out_args) = generate_in_args(fn_type);
        let in_args: Vec<_> = vec![quote!(&self)].into_iter().chain(in_args).collect();

        let name = field.ident.unwrap();
        let output = &fn_type.output;
        let function = quote! {
            pub unsafe fn #name(#(#in_args),*) #output
        };

        src.push_str(&format!("    {} {{\n", function));

        // Perform conversions
        for conversion in conversions {
            src.push_str(&format!("        {}\n", conversion));
        }

        // Call into the field
        let call = quote! {
            ((*self.0).#name).unsafe_unwrap()(#(#out_args),*)
        };
        src.push_str(&format!("        {}\n", call));

        src.push_str("    }\n\n");
    }

    src.push_str("}\n\n");
}

fn generate_in_args<'a>(
    fn_type: &'a TypeBareFn,
) -> (Vec<TokenStream>, Vec<TokenStream>, Vec<TokenStream>) {
    let mut in_args = Vec::new();
    let mut conversions = Vec::new();
    let mut out_args = Vec::new();

    for input in &fn_type.inputs {
        let name = &input.name.as_ref().unwrap().0;

        let raw_ty = &input.ty;
        let mut in_ty = quote! {#raw_ty};
        let mut out_arg = quote!(#name);

        // If this is a type we can convert, add a conversion
        if let Type::Ptr(ptr) = &input.ty {
            if let Type::Path(ty_path) = ptr.elem.as_ref() {
                if ty_path.path.segments.last().unwrap().ident == "c_char" {
                    let conversion = quote! {
                        let #name = std::ffi::CString::new(#name).unwrap();
                    };
                    conversions.push(conversion);

                    in_ty = quote! { &str };
                    out_arg = quote! { #name.as_ptr() };
                }
            }
        }

        in_args.push(quote!(#name: #in_ty));
        out_args.push(out_arg);
    }

    (in_args, conversions, out_args)
}
