use std::{fs, path::Path, process::Command};

use heck::{CamelCase, ShoutySnakeCase};
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;
use syn::{GenericArgument, Item, ItemStruct, PathArguments, Type, TypeBareFn};

fn main() {
    let out_path = Path::new("./src/generated/foundation.rs");

    // Only generate if the file doesn't exist already
    if out_path.exists() {
        return;
    }

    let blocklist = vec!["tm_api_registry_api"];

    // Load the input file
    let input = fs::read_to_string("../machinery-sys/src/foundation.rs").unwrap();
    let file = syn::parse_file(&input).unwrap();

    let mut src = String::new();
    src.push_str("// Code generated by machinery's build.rs\n\n");
    src.push_str("use unsafe_unwrap::UnsafeUnwrap;\n");
    src.push_str("use machinery_sys::foundation::*;\n\n");

    for item in file.items {
        if let Item::Struct(item) = item {
            let name = item.ident.to_string();

            if blocklist.contains(&name.as_str()) {
                continue;
            }

            // Skip anything that isn't an API
            if !name.ends_with("_api") {
                continue;
            }

            generate_api(&mut src, item);
        }
    }

    fs::write(out_path, src).unwrap();

    // Run rustfmt on the output file
    Command::new("rustfmt")
        .args(&[out_path.to_str().unwrap()])
        .status()
        .expect("Failed to run rustfmt");
}

fn generate_api(src: &mut String, item: ItemStruct) {
    let raw_name = item.ident;
    let name = raw_name.to_string()[3..].to_camel_case();

    src.push_str(&format!(
        "pub struct {}(pub *const {});\n\n",
        name, raw_name
    ));

    src.push_str(&format!("impl {} {{\n", name));

    for field in item.fields {
        let path_type = if let Type::Path(path_type) = field.ty {
            path_type
        } else {
            continue;
        };

        // Extract the type
        let segment = path_type.path.segments.last().unwrap();
        if segment.ident != "Option" {
            // Skip non-options, they're not what we're looking for
            continue;
        }

        let arguments = if let PathArguments::AngleBracketed(ref arguments) = segment.arguments {
            arguments
        } else {
            continue;
        };

        let type_arg = if let GenericArgument::Type(ref type_arg) = arguments.args[0] {
            type_arg
        } else {
            continue;
        };

        let fn_type = if let Type::BareFn(fn_type) = type_arg {
            fn_type
        } else {
            continue;
        };

        // Convert the parameters
        let (in_args, conversions, out_args) = generate_in_args(fn_type);
        let in_args: Vec<_> = vec![quote!(&self)].into_iter().chain(in_args).collect();

        let name = field.ident.unwrap();
        let output = &fn_type.output;
        let function = quote! {
            pub unsafe fn #name(#(#in_args),*) #output
        };

        src.push_str(&format!("{} {{\n", function));

        // Perform conversions
        for conversion in conversions {
            src.push_str(&format!("{}\n", conversion));
        }

        // Call into the field
        let call = quote! {
            ((*self.0).#name).unsafe_unwrap()(#(#out_args),*)
        };
        src.push_str(&format!("{}\n", call));

        src.push_str("}\n\n");
    }

    src.push_str("}\n\n");

    // Trait implementation for fetching from the registry
    let name_ident = Ident::new(
        &format!("{}_NAME", raw_name.to_string().to_shouty_snake_case()),
        Span::call_site(),
    );
    let name_token = Ident::new(&name, Span::call_site());
    let reg_impl = quote! {
        impl crate::Api for #name_token {
            const NAME: *const i8 = #name_ident as *const _ as *const i8;

            unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
                Self(raw as *const #raw_name)
            }
        }

        unsafe impl Send for #name_token {}
        unsafe impl Sync for #name_token {}
    };
    src.push_str(&reg_impl.to_string());
    src.push_str("\n");
}

fn generate_in_args<'a>(
    fn_type: &'a TypeBareFn,
) -> (Vec<TokenStream>, Vec<TokenStream>, Vec<TokenStream>) {
    let mut in_args = Vec::new();
    let mut conversions = Vec::new();
    let mut out_args = Vec::new();

    for input in &fn_type.inputs {
        let name = &input.name.as_ref().unwrap().0;

        let raw_ty = &input.ty;
        let mut in_ty = quote! {#raw_ty};
        let mut out_arg = quote!(#name);

        // If this is a type we can convert, add a conversion
        if let Type::Ptr(ptr) = &input.ty {
            if let Type::Path(ty_path) = ptr.elem.as_ref() {
                if ty_path.path.segments.last().unwrap().ident == "c_char" {
                    let conversion = quote! {
                        let #name = std::ffi::CString::new(#name).unwrap();
                    };
                    conversions.push(conversion);

                    in_ty = quote! { &str };
                    out_arg = quote! { #name.as_ptr() };
                }
            }
        }

        in_args.push(quote!(#name: #in_ty));
        out_args.push(out_arg);
    }

    (in_args, conversions, out_args)
}
