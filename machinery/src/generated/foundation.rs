// Code generated by machinery's build.rs

use machinery_sys::foundation::*;
use unsafe_unwrap::UnsafeUnwrap;

pub struct AllocatorApi(pub *const tm_allocator_api);

impl AllocatorApi {
    pub unsafe fn create_child(
        &self,
        parent: *const tm_allocator_i,
        desc: &std::ffi::CStr,
    ) -> tm_allocator_i {
        let desc = desc.as_ptr();
        ((*self.0).create_child).unsafe_unwrap()(parent, desc)
    }

    pub unsafe fn destroy_child(&self, child: *const tm_allocator_i) {
        ((*self.0).destroy_child).unsafe_unwrap()(child)
    }

    pub unsafe fn destroy_child_allowing_leaks(
        &self,
        child: *const tm_allocator_i,
        max_leaked_bytes: u64,
    ) {
        ((*self.0).destroy_child_allowing_leaks).unsafe_unwrap()(child, max_leaked_bytes)
    }

    pub unsafe fn create_leaky_root_scope(
        &self,
        parent: *const tm_allocator_i,
        desc: &std::ffi::CStr,
    ) -> tm_allocator_i {
        let desc = desc.as_ptr();
        ((*self.0).create_leaky_root_scope).unsafe_unwrap()(parent, desc)
    }

    pub unsafe fn create_fixed_vm(&self, reserve_size: u64, mem_scope: u32) -> tm_allocator_i {
        ((*self.0).create_fixed_vm).unsafe_unwrap()(reserve_size, mem_scope)
    }
}

impl crate::Api for AllocatorApi {
    const NAME: *const i8 = TM_ALLOCATOR_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_allocator_api)
    }
}
unsafe impl Send for AllocatorApi {}
unsafe impl Sync for AllocatorApi {}
pub struct ApplicationApi(pub *const tm_application_api);

impl ApplicationApi {
    pub unsafe fn application(&self) -> *mut tm_application_o {
        ((*self.0).application).unsafe_unwrap()()
    }

    pub unsafe fn create(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut tm_application_o {
        ((*self.0).create).unsafe_unwrap()(argc, argv)
    }

    pub unsafe fn tick(&self, app: *mut tm_application_o) -> bool {
        ((*self.0).tick).unsafe_unwrap()(app)
    }

    pub unsafe fn destroy(&self, app: *mut tm_application_o) {
        ((*self.0).destroy).unsafe_unwrap()(app)
    }

    pub unsafe fn set_modal(
        &self,
        app: *mut tm_application_o,
        f: tm_application_modal_f,
        data: *mut ::std::os::raw::c_void,
    ) {
        ((*self.0).set_modal).unsafe_unwrap()(app, f, data)
    }

    pub unsafe fn is_modal(&self, app: *const tm_application_o) -> bool {
        ((*self.0).is_modal).unsafe_unwrap()(app)
    }

    pub unsafe fn asset_root(&self, app: *const tm_application_o) -> tm_tt_id_t {
        ((*self.0).asset_root).unsafe_unwrap()(app)
    }

    pub unsafe fn load_core(&self, app: *const tm_application_o) -> bool {
        ((*self.0).load_core).unsafe_unwrap()(app)
    }

    pub unsafe fn update_core(&self, app: *const tm_application_o) -> bool {
        ((*self.0).update_core).unsafe_unwrap()(app)
    }

    pub unsafe fn exit(&self, app: *mut tm_application_o) {
        ((*self.0).exit).unsafe_unwrap()(app)
    }

    pub unsafe fn set_cursor_hidden(&self, app: *mut tm_application_o, hidden: bool) {
        ((*self.0).set_cursor_hidden).unsafe_unwrap()(app, hidden)
    }

    pub unsafe fn viewer_manager(&self, app: *mut tm_application_o) -> *mut tm_viewer_manager_o {
        ((*self.0).viewer_manager).unsafe_unwrap()(app)
    }

    pub unsafe fn default_render_pipeline_api(
        &self,
        app: *mut tm_application_o,
    ) -> *mut tm_render_pipeline_api {
        ((*self.0).default_render_pipeline_api).unsafe_unwrap()(app)
    }

    pub unsafe fn ui_scale_factor(&self, app: *mut tm_application_o, ui: *mut tm_ui_o) -> f32 {
        ((*self.0).ui_scale_factor).unsafe_unwrap()(app, ui)
    }

    pub unsafe fn data_dir(&self, app: *mut tm_application_o) -> *const ::std::os::raw::c_char {
        ((*self.0).data_dir).unsafe_unwrap()(app)
    }

    pub unsafe fn color_space(
        &self,
        app: *const tm_application_o,
        color_space: *mut tm_color_space_desc_t,
        format: *mut u32,
    ) {
        ((*self.0).color_space).unsafe_unwrap()(app, color_space, format)
    }
}

impl crate::Api for ApplicationApi {
    const NAME: *const i8 = TM_APPLICATION_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_application_api)
    }
}
unsafe impl Send for ApplicationApi {}
unsafe impl Sync for ApplicationApi {}
pub struct AssetDatabaseApi(pub *const tm_asset_database_api);

impl AssetDatabaseApi {
    pub unsafe fn create(
        &self,
        file: &std::ffi::CStr,
        tt: *mut tm_the_truth_o,
        config: *const tm_asset_database_config_t,
    ) -> *mut tm_asset_database_o {
        let file = file.as_ptr();
        ((*self.0).create).unsafe_unwrap()(file, tt, config)
    }

    pub unsafe fn open(
        &self,
        file: &std::ffi::CStr,
        tt: *mut tm_the_truth_o,
        config: *const tm_asset_database_config_t,
    ) -> *mut tm_asset_database_o {
        let file = file.as_ptr();
        ((*self.0).open).unsafe_unwrap()(file, tt, config)
    }

    pub unsafe fn close(&self, db: *mut tm_asset_database_o) {
        ((*self.0).close).unsafe_unwrap()(db)
    }

    pub unsafe fn save_modified(&self, db: *mut tm_asset_database_o, asset_root: tm_tt_id_t) {
        ((*self.0).save_modified).unsafe_unwrap()(db, asset_root)
    }

    pub unsafe fn save_modified_except(
        &self,
        db: *mut tm_asset_database_o,
        asset_root: tm_tt_id_t,
        ignore: *mut tm_tt_id_t,
        num_ignore: u32,
    ) {
        ((*self.0).save_modified_except).unsafe_unwrap()(db, asset_root, ignore, num_ignore)
    }

    pub unsafe fn save_asset(&self, db: *mut tm_asset_database_o, asset: tm_tt_id_t) {
        ((*self.0).save_asset).unsafe_unwrap()(db, asset)
    }

    pub unsafe fn delete_asset(&self, db: *mut tm_asset_database_o, asset: tm_tt_id_t) {
        ((*self.0).delete_asset).unsafe_unwrap()(db, asset)
    }

    pub unsafe fn revert_asset(
        &self,
        db: *mut tm_asset_database_o,
        asset: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) -> bool {
        ((*self.0).revert_asset).unsafe_unwrap()(db, asset, undo_scope)
    }

    pub unsafe fn load(&self, db: *mut tm_asset_database_o, load_fraction: *mut f32) -> tm_tt_id_t {
        ((*self.0).load).unsafe_unwrap()(db, load_fraction)
    }

    pub unsafe fn saved_name(
        &self,
        db: *mut tm_asset_database_o,
        item: tm_uuid_t,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).saved_name).unsafe_unwrap()(db, item)
    }

    pub unsafe fn saved_directory(
        &self,
        db: *mut tm_asset_database_o,
        item: tm_uuid_t,
    ) -> tm_uuid_t {
        ((*self.0).saved_directory).unsafe_unwrap()(db, item)
    }

    pub unsafe fn saved_version(&self, db: *mut tm_asset_database_o, asset: tm_uuid_t) -> u64 {
        ((*self.0).saved_version).unsafe_unwrap()(db, asset)
    }

    pub unsafe fn all_saved_items(
        &self,
        db: *mut tm_asset_database_o,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_asset_dabase_saved_item_t {
        ((*self.0).all_saved_items).unsafe_unwrap()(db, ta)
    }
}

impl crate::Api for AssetDatabaseApi {
    const NAME: *const i8 = TM_ASSET_DATABASE_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_asset_database_api)
    }
}
unsafe impl Send for AssetDatabaseApi {}
unsafe impl Sync for AssetDatabaseApi {}
pub struct AssetIoApi(pub *const tm_asset_io_api);

impl AssetIoApi {
    pub unsafe fn add_asset_io(&self, loader: *mut tm_asset_io_i) {
        ((*self.0).add_asset_io).unsafe_unwrap()(loader)
    }

    pub unsafe fn remove_asset_io(&self, loader: *mut tm_asset_io_i) {
        ((*self.0).remove_asset_io).unsafe_unwrap()(loader)
    }

    pub unsafe fn importer(&self, extension: &std::ffi::CStr) -> *mut tm_asset_io_i {
        let extension = extension.as_ptr();
        ((*self.0).importer).unsafe_unwrap()(extension)
    }

    pub unsafe fn reimporter(
        &self,
        tt: *mut tm_the_truth_o,
        asset: tm_tt_id_t,
    ) -> *mut tm_asset_io_i {
        ((*self.0).reimporter).unsafe_unwrap()(tt, asset)
    }

    pub unsafe fn exporter(
        &self,
        tt: *mut tm_the_truth_o,
        asset: tm_tt_id_t,
    ) -> *mut tm_asset_io_i {
        ((*self.0).exporter).unsafe_unwrap()(tt, asset)
    }

    pub unsafe fn io_interfaces(&self, interfaces: *mut *mut tm_asset_io_i) -> u32 {
        ((*self.0).io_interfaces).unsafe_unwrap()(interfaces)
    }
}

impl crate::Api for AssetIoApi {
    const NAME: *const i8 = TM_ASSET_IO_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_asset_io_api)
    }
}
unsafe impl Send for AssetIoApi {}
unsafe impl Sync for AssetIoApi {}
pub struct Base64Api(pub *const tm_base_64_api);

impl Base64Api {
    pub unsafe fn encoded_size(&self, raw_size: u64) -> u64 {
        ((*self.0).encoded_size).unsafe_unwrap()(raw_size)
    }

    pub unsafe fn encode(
        &self,
        encoded: *mut ::std::os::raw::c_char,
        raw: *const u8,
        raw_size: u64,
    ) -> u64 {
        ((*self.0).encode).unsafe_unwrap()(encoded, raw, raw_size)
    }

    pub unsafe fn decoded_size(&self, encoded: &std::ffi::CStr, encoded_size: u64) -> u64 {
        let encoded = encoded.as_ptr();
        ((*self.0).decoded_size).unsafe_unwrap()(encoded, encoded_size)
    }

    pub unsafe fn decode(&self, raw: *mut u8, encoded: &std::ffi::CStr, encoded_size: u64) -> u64 {
        let encoded = encoded.as_ptr();
        ((*self.0).decode).unsafe_unwrap()(raw, encoded, encoded_size)
    }
}

impl crate::Api for Base64Api {
    const NAME: *const i8 = TM_BASE_64_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_base_64_api)
    }
}
unsafe impl Send for Base64Api {}
unsafe impl Sync for Base64Api {}
pub struct BuddyAllocatorRawApi(pub *const tm_buddy_allocator_raw_api);

impl BuddyAllocatorRawApi {
    pub unsafe fn init(&self, buffer: *mut u8, size: u32, block_size: u32) {
        ((*self.0).init).unsafe_unwrap()(buffer, size, block_size)
    }

    pub unsafe fn realloc(
        &self,
        buffer: *mut u8,
        ptr: *mut ::std::os::raw::c_void,
        old_size: u64,
        new_size: u64,
    ) -> *mut ::std::os::raw::c_void {
        ((*self.0).realloc).unsafe_unwrap()(buffer, ptr, old_size, new_size)
    }
}

impl crate::Api for BuddyAllocatorRawApi {
    const NAME: *const i8 = TM_BUDDY_ALLOCATOR_RAW_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_buddy_allocator_raw_api)
    }
}
unsafe impl Send for BuddyAllocatorRawApi {}
unsafe impl Sync for BuddyAllocatorRawApi {}
pub struct BuddyAllocatorApi(pub *const tm_buddy_allocator_api);

impl BuddyAllocatorApi {
    pub unsafe fn create(
        &self,
        backing: *mut tm_allocator_i,
        initial_size: u32,
        block_size: u32,
    ) -> *mut tm_allocator_i {
        ((*self.0).create).unsafe_unwrap()(backing, initial_size, block_size)
    }

    pub unsafe fn destroy(&self, a: *mut tm_allocator_i) {
        ((*self.0).destroy).unsafe_unwrap()(a)
    }
}

impl crate::Api for BuddyAllocatorApi {
    const NAME: *const i8 = TM_BUDDY_ALLOCATOR_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_buddy_allocator_api)
    }
}
unsafe impl Send for BuddyAllocatorApi {}
unsafe impl Sync for BuddyAllocatorApi {}
pub struct BuffersApi(pub *const tm_buffers_api);

impl BuffersApi {
    pub unsafe fn create(&self, a: *mut tm_allocator_i) -> *mut tm_buffers_i {
        ((*self.0).create).unsafe_unwrap()(a)
    }

    pub unsafe fn destroy(&self, i: *mut tm_buffers_i) {
        ((*self.0).destroy).unsafe_unwrap()(i)
    }

    pub unsafe fn create_streamable(
        &self,
        a: *mut tm_allocator_i,
        io: *mut tm_os_file_io_api,
    ) -> *mut tm_streamable_buffers_i {
        ((*self.0).create_streamable).unsafe_unwrap()(a, io)
    }

    pub unsafe fn destroy_streamable(&self, i: *mut tm_streamable_buffers_i) {
        ((*self.0).destroy_streamable).unsafe_unwrap()(i)
    }
}

impl crate::Api for BuffersApi {
    const NAME: *const i8 = TM_BUFFERS_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_buffers_api)
    }
}
unsafe impl Send for BuffersApi {}
unsafe impl Sync for BuffersApi {}
pub struct BufferFormatApi(pub *const tm_buffer_format_api);

impl BufferFormatApi {
    pub unsafe fn encode_uncompressed_format(
        &self,
        component_type: tm_buffer_component_type,
        sign: bool,
        bits_x: u8,
        bits_y: u8,
        bits_z: u8,
        bits_w: u8,
    ) -> u32 {
        ((*self.0).encode_uncompressed_format).unsafe_unwrap()(
            component_type,
            sign,
            bits_x,
            bits_y,
            bits_z,
            bits_w,
        )
    }

    pub unsafe fn encode_compressed_format(
        &self,
        compression_type: tm_buffer_compression_format,
    ) -> u32 {
        ((*self.0).encode_compressed_format).unsafe_unwrap()(compression_type)
    }

    pub unsafe fn is_compressed(&self, format: u32) -> bool {
        ((*self.0).is_compressed).unsafe_unwrap()(format)
    }

    pub unsafe fn decode_uncompressed(
        &self,
        format: u32,
        component_type: *mut tm_buffer_component_type,
        sign: *mut bool,
        bits_x: *mut u8,
        bits_y: *mut u8,
        bits_z: *mut u8,
        bits_w: *mut u8,
    ) -> bool {
        ((*self.0).decode_uncompressed).unsafe_unwrap()(
            format,
            component_type,
            sign,
            bits_x,
            bits_y,
            bits_z,
            bits_w,
        )
    }

    pub unsafe fn decode_compression_format(
        &self,
        format: u32,
        compression_format: *mut tm_buffer_compression_format,
    ) -> bool {
        ((*self.0).decode_compression_format).unsafe_unwrap()(format, compression_format)
    }

    pub unsafe fn bits_per_element(&self, format: u32) -> u32 {
        ((*self.0).bits_per_element).unsafe_unwrap()(format)
    }

    pub unsafe fn num_components(&self, format: u32) -> u32 {
        ((*self.0).num_components).unsafe_unwrap()(format)
    }

    pub unsafe fn human_readable(
        &self,
        format: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).human_readable).unsafe_unwrap()(format, ta)
    }
}

impl crate::Api for BufferFormatApi {
    const NAME: *const i8 = TM_BUFFER_FORMAT_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_buffer_format_api)
    }
}
unsafe impl Send for BufferFormatApi {}
unsafe impl Sync for BufferFormatApi {}
pub struct CameraApi(pub *const tm_camera_api);

impl CameraApi {
    pub unsafe fn view_from_transform(
        &self,
        view: *mut tm_mat44_t,
        tm: *const tm_transform_t,
    ) -> *mut tm_mat44_t {
        ((*self.0).view_from_transform).unsafe_unwrap()(view, tm)
    }

    pub unsafe fn transform_from_view(
        &self,
        tm: *mut tm_transform_t,
        view: *const tm_mat44_t,
    ) -> *mut tm_transform_t {
        ((*self.0).transform_from_view).unsafe_unwrap()(tm, view)
    }

    pub unsafe fn projection_from_frustum(
        &self,
        proj: *mut tm_mat44_t,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) -> *mut tm_mat44_t {
        ((*self.0).projection_from_frustum).unsafe_unwrap()(
            proj, left, right, bottom, top, near, far,
        )
    }

    pub unsafe fn projection_from_fov(
        &self,
        proj: *mut tm_mat44_t,
        near_plane: f32,
        far_plane: f32,
        vertical_fov: f32,
        aspect: f32,
    ) -> *mut tm_mat44_t {
        ((*self.0).projection_from_fov).unsafe_unwrap()(
            proj,
            near_plane,
            far_plane,
            vertical_fov,
            aspect,
        )
    }

    pub unsafe fn orthographic_from_frustum(
        &self,
        proj: *mut tm_mat44_t,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
    ) -> *mut tm_mat44_t {
        ((*self.0).orthographic_from_frustum).unsafe_unwrap()(
            proj, left, right, bottom, top, near, far,
        )
    }

    pub unsafe fn orthographics_from_dimensions(
        &self,
        proj: *mut tm_mat44_t,
        near_plane: f32,
        far_plane: f32,
        width: f32,
        height: f32,
    ) -> *mut tm_mat44_t {
        ((*self.0).orthographics_from_dimensions).unsafe_unwrap()(
            proj, near_plane, far_plane, width, height,
        )
    }

    pub unsafe fn projection_from_camera(
        &self,
        camera: *mut tm_camera_t,
        transform: tm_camera_transform,
        aspect: f32,
    ) -> *mut tm_mat44_t {
        ((*self.0).projection_from_camera).unsafe_unwrap()(camera, transform, aspect)
    }

    pub unsafe fn update_free_flight(&self, tm: *mut tm_transform_t, t: tm_vec3_t, r: tm_vec2_t) {
        ((*self.0).update_free_flight).unsafe_unwrap()(tm, t, r)
    }

    pub unsafe fn update_pan(
        &self,
        tm: *mut tm_transform_t,
        focus_position: *mut tm_vec3_t,
        pan: tm_vec2_t,
    ) {
        ((*self.0).update_pan).unsafe_unwrap()(tm, focus_position, pan)
    }

    pub unsafe fn update_maya(
        &self,
        tm: *mut tm_transform_t,
        focus_position: tm_vec3_t,
        zoom: f32,
        rot: tm_vec2_t,
    ) {
        ((*self.0).update_maya).unsafe_unwrap()(tm, focus_position, zoom, rot)
    }

    pub unsafe fn world_to_screen(
        &self,
        camera: *const tm_camera_t,
        transform: tm_camera_transform,
        viewport: tm_rect_t,
        world: *const tm_vec3_t,
        screen: *mut tm_vec3_t,
        n: u32,
    ) -> *mut tm_vec3_t {
        ((*self.0).world_to_screen).unsafe_unwrap()(camera, transform, viewport, world, screen, n)
    }

    pub unsafe fn screen_to_world(
        &self,
        camera: *const tm_camera_t,
        transform: tm_camera_transform,
        viewport: tm_rect_t,
        screen: *const tm_vec3_t,
        world: *mut tm_vec3_t,
        n: u32,
    ) -> *mut tm_vec3_t {
        ((*self.0).screen_to_world).unsafe_unwrap()(camera, transform, viewport, screen, world, n)
    }

    pub unsafe fn meters_per_pixel(
        &self,
        distance: f32,
        vertical_fov: f32,
        viewport_height: f32,
    ) -> f32 {
        ((*self.0).meters_per_pixel).unsafe_unwrap()(distance, vertical_fov, viewport_height)
    }

    pub unsafe fn default_camera(&self) -> *const tm_camera_t {
        ((*self.0).default_camera).unsafe_unwrap()()
    }

    pub unsafe fn frustum_planes_from_view_projection(
        &self,
        view: *const tm_mat44_t,
        projection: *const tm_mat44_t,
        frustum_planes: *mut tm_vec4_t,
    ) {
        ((*self.0).frustum_planes_from_view_projection).unsafe_unwrap()(
            view,
            projection,
            frustum_planes,
        )
    }
}

impl crate::Api for CameraApi {
    const NAME: *const i8 = TM_CAMERA_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_camera_api)
    }
}
unsafe impl Send for CameraApi {}
unsafe impl Sync for CameraApi {}
pub struct CollaborationApi(pub *const tm_collaboration_api);

impl CollaborationApi {
    pub unsafe fn create(
        &self,
        a: *mut tm_allocator_i,
        config: *const tm_collaboration_config_i,
    ) -> *mut tm_collaboration_o {
        ((*self.0).create).unsafe_unwrap()(a, config)
    }

    pub unsafe fn destroy(&self, coll: *mut tm_collaboration_o) {
        ((*self.0).destroy).unsafe_unwrap()(coll)
    }

    pub unsafe fn status(&self, coll: *const tm_collaboration_o) -> tm_collaboration_status {
        ((*self.0).status).unsafe_unwrap()(coll)
    }

    pub unsafe fn is_downloading(
        &self,
        coll: *const tm_collaboration_o,
        bytes: *mut u64,
        total: *mut u64,
    ) -> bool {
        ((*self.0).is_downloading).unsafe_unwrap()(coll, bytes, total)
    }

    pub unsafe fn set_session(
        &self,
        coll: *mut tm_collaboration_o,
        session: *const tm_collaboration_session_i,
    ) {
        ((*self.0).set_session).unsafe_unwrap()(coll, session)
    }

    pub unsafe fn session(&self, coll: *mut tm_collaboration_o) -> *mut tm_collaboration_session_i {
        ((*self.0).session).unsafe_unwrap()(coll)
    }

    pub unsafe fn disconnect(&self, coll: *mut tm_collaboration_o) {
        ((*self.0).disconnect).unsafe_unwrap()(coll)
    }

    pub unsafe fn update(&self, coll: *mut tm_collaboration_o) {
        ((*self.0).update).unsafe_unwrap()(coll)
    }

    pub unsafe fn handle(&self, coll: *const tm_collaboration_o) -> *const ::std::os::raw::c_char {
        ((*self.0).handle).unsafe_unwrap()(coll)
    }

    pub unsafe fn set_handle(
        &self,
        c: *mut tm_collaboration_o,
        handle: *mut ::std::os::raw::c_char,
    ) {
        ((*self.0).set_handle).unsafe_unwrap()(c, handle)
    }

    pub unsafe fn host_handle(
        &self,
        c: *const tm_collaboration_o,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).host_handle).unsafe_unwrap()(c)
    }

    pub unsafe fn num_clients(&self, coll: *const tm_collaboration_o) -> u32 {
        ((*self.0).num_clients).unsafe_unwrap()(coll)
    }

    pub unsafe fn client_handle(
        &self,
        coll: *const tm_collaboration_o,
        i: u32,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).client_handle).unsafe_unwrap()(coll, i)
    }

    pub unsafe fn all_handles(
        &self,
        coll: *const tm_collaboration_o,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut *const ::std::os::raw::c_char {
        ((*self.0).all_handles).unsafe_unwrap()(coll, ta)
    }

    pub unsafe fn send_chat(&self, coll: *mut tm_collaboration_o, msg: &std::ffi::CStr) {
        let msg = msg.as_ptr();
        ((*self.0).send_chat).unsafe_unwrap()(coll, msg)
    }

    pub unsafe fn num_chat_messages(&self, coll: *const tm_collaboration_o) -> u32 {
        ((*self.0).num_chat_messages).unsafe_unwrap()(coll)
    }

    pub unsafe fn chat_message(
        &self,
        coll: *const tm_collaboration_o,
        i: u32,
        sender: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).chat_message).unsafe_unwrap()(coll, i, sender)
    }

    pub unsafe fn resynchronize_state(
        &self,
        coll: *mut tm_collaboration_o,
        tt: *mut tm_the_truth_o,
    ) {
        ((*self.0).resynchronize_state).unsafe_unwrap()(coll, tt)
    }

    pub unsafe fn send_test_packages(&self, coll: *mut tm_collaboration_o, size: u64, num: u32) {
        ((*self.0).send_test_packages).unsafe_unwrap()(coll, size, num)
    }
}

impl crate::Api for CollaborationApi {
    const NAME: *const i8 = TM_COLLABORATION_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_collaboration_api)
    }
}
unsafe impl Send for CollaborationApi {}
unsafe impl Sync for CollaborationApi {}
pub struct CollaborationP2pApi(pub *const tm_collaboration_p2p_api);

impl CollaborationP2pApi {
    pub unsafe fn create(
        &self,
        coll: *mut tm_collaboration_o,
        allocator: *mut tm_allocator_i,
    ) -> *mut tm_collaboration_p2p_o {
        ((*self.0).create).unsafe_unwrap()(coll, allocator)
    }

    pub unsafe fn destroy(&self, coll_p2p: *mut tm_collaboration_p2p_o) {
        ((*self.0).destroy).unsafe_unwrap()(coll_p2p)
    }

    pub unsafe fn update(&self, coll_p2p: *mut tm_collaboration_p2p_o) {
        ((*self.0).update).unsafe_unwrap()(coll_p2p)
    }

    pub unsafe fn host(&self, coll_p2p: *mut tm_collaboration_p2p_o, port: u32, use_upnp: bool) {
        ((*self.0).host).unsafe_unwrap()(coll_p2p, port, use_upnp)
    }

    pub unsafe fn connect(
        &self,
        coll_p2p: *mut tm_collaboration_p2p_o,
        address: *const tm_socket_address_t,
    ) {
        ((*self.0).connect).unsafe_unwrap()(coll_p2p, address)
    }

    pub unsafe fn discovered_lan_hosts(
        &self,
        coll_p2p: *const tm_collaboration_p2p_o,
        hosts: *mut tm_collaboration_discovered_host_t,
        max_hosts: u32,
    ) -> u32 {
        ((*self.0).discovered_lan_hosts).unsafe_unwrap()(coll_p2p, hosts, max_hosts)
    }
}

impl crate::Api for CollaborationP2pApi {
    const NAME: *const i8 = TM_COLLABORATION_P2P_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_collaboration_p2p_api)
    }
}
unsafe impl Send for CollaborationP2pApi {}
unsafe impl Sync for CollaborationP2pApi {}
pub struct ConfigApi(pub *const tm_config_api);

impl ConfigApi {
    pub unsafe fn create(&self, a: *mut tm_allocator_i) -> *mut tm_config_i {
        ((*self.0).create).unsafe_unwrap()(a)
    }

    pub unsafe fn destroy(&self, cdi: *mut tm_config_i) {
        ((*self.0).destroy).unsafe_unwrap()(cdi)
    }
}

impl crate::Api for ConfigApi {
    const NAME: *const i8 = TM_CONFIG_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_config_api)
    }
}
unsafe impl Send for ConfigApi {}
unsafe impl Sync for ConfigApi {}
pub struct CoreApi(pub *const tm_core_api);

impl CoreApi {
    pub unsafe fn create(&self, tt: *mut tm_the_truth_o, asset_root_id: tm_tt_id_t) {
        ((*self.0).create).unsafe_unwrap()(tt, asset_root_id)
    }

    pub unsafe fn update(
        &self,
        tt: *mut tm_the_truth_o,
        asset_root_id: tm_tt_id_t,
        ta: *mut tm_temp_allocator_i,
    ) -> tm_core_update_result_t {
        ((*self.0).update).unsafe_unwrap()(tt, asset_root_id, ta)
    }

    pub unsafe fn locate_asset(
        &self,
        tt: *mut tm_the_truth_o,
        asset_root_id: tm_tt_id_t,
        core_id: tm_strhash_t,
    ) -> tm_tt_id_t {
        ((*self.0).locate_asset).unsafe_unwrap()(tt, asset_root_id, core_id)
    }
}

impl crate::Api for CoreApi {
    const NAME: *const i8 = TM_CORE_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_core_api)
    }
}
unsafe impl Send for CoreApi {}
unsafe impl Sync for CoreApi {}
pub struct CoreImporterApi(pub *const tm_core_importer_api);

impl CoreImporterApi {
    pub unsafe fn create(
        &self,
        a: *mut tm_allocator_i,
        user_tt: *mut tm_the_truth_o,
        user_asset_root: tm_tt_id_t,
        core_project_path: &std::ffi::CStr,
        output_path: &std::ffi::CStr,
    ) -> *mut tm_core_importer_state_o {
        let core_project_path = core_project_path.as_ptr();
        let output_path = output_path.as_ptr();
        ((*self.0).create).unsafe_unwrap()(
            a,
            user_tt,
            user_asset_root,
            core_project_path,
            output_path,
        )
    }

    pub unsafe fn destroy(&self, state: *mut tm_core_importer_state_o) {
        ((*self.0).destroy).unsafe_unwrap()(state)
    }

    pub unsafe fn register_assets(
        &self,
        state: *mut tm_core_importer_state_o,
        to_register: *const tm_core_importer_asset_t,
        num_to_register: u32,
    ) {
        ((*self.0).register_assets).unsafe_unwrap()(state, to_register, num_to_register)
    }
}

impl crate::Api for CoreImporterApi {
    const NAME: *const i8 = TM_CORE_IMPORTER_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_core_importer_api)
    }
}
unsafe impl Send for CoreImporterApi {}
unsafe impl Sync for CoreImporterApi {}
pub struct CrashRecoveryApi(pub *const tm_crash_recovery_api);

impl CrashRecoveryApi {
    pub unsafe fn create(
        &self,
        a: *mut tm_allocator_i,
        recovery_path: &std::ffi::CStr,
    ) -> *mut tm_crash_recovery_o {
        let recovery_path = recovery_path.as_ptr();
        ((*self.0).create).unsafe_unwrap()(a, recovery_path)
    }

    pub unsafe fn destroy(&self, cr: *mut tm_crash_recovery_o) {
        ((*self.0).destroy).unsafe_unwrap()(cr)
    }

    pub unsafe fn start_recording(
        &self,
        cr: *mut tm_crash_recovery_o,
        project: &std::ffi::CStr,
        tt: *mut tm_the_truth_o,
        root: tm_tt_id_t,
    ) {
        let project = project.as_ptr();
        ((*self.0).start_recording).unsafe_unwrap()(cr, project, tt, root)
    }

    pub unsafe fn stop_recording(&self, cr: *mut tm_crash_recovery_o) {
        ((*self.0).stop_recording).unsafe_unwrap()(cr)
    }

    pub unsafe fn update(&self, cr: *mut tm_crash_recovery_o) {
        ((*self.0).update).unsafe_unwrap()(cr)
    }

    pub unsafe fn can_recover(
        &self,
        cr: *mut tm_crash_recovery_o,
        ta: *mut tm_temp_allocator_i,
    ) -> tm_crash_recovery_can_recover_result_t {
        ((*self.0).can_recover).unsafe_unwrap()(cr, ta)
    }

    pub unsafe fn recover(
        &self,
        cr: *mut tm_crash_recovery_o,
        rd: tm_crash_recovery_can_recover_result_t,
        tt: *mut tm_the_truth_o,
    ) {
        ((*self.0).recover).unsafe_unwrap()(cr, rd, tt)
    }

    pub unsafe fn delete_physical_file(&self, cr: *mut tm_crash_recovery_o) {
        ((*self.0).delete_physical_file).unsafe_unwrap()(cr)
    }
}

impl crate::Api for CrashRecoveryApi {
    const NAME: *const i8 = TM_CRASH_RECOVERY_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_crash_recovery_api)
    }
}
unsafe impl Send for CrashRecoveryApi {}
unsafe impl Sync for CrashRecoveryApi {}
pub struct ErrorApi(pub *const tm_error_api);

impl ErrorApi {
    pub unsafe fn create_record_handler(&self, mem: *mut tm_error_record_t) -> tm_error_i {
        ((*self.0).create_record_handler).unsafe_unwrap()(mem)
    }
}

impl crate::Api for ErrorApi {
    const NAME: *const i8 = TM_ERROR_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_error_api)
    }
}
unsafe impl Send for ErrorApi {}
unsafe impl Sync for ErrorApi {}
pub struct FeatureFlagsApi(pub *const tm_feature_flags_api);

impl FeatureFlagsApi {
    pub unsafe fn enabled(&self, flag: tm_strhash_t) -> bool {
        ((*self.0).enabled).unsafe_unwrap()(flag)
    }

    pub unsafe fn set_enabled(&self, flag: tm_strhash_t, enabled: bool) {
        ((*self.0).set_enabled).unsafe_unwrap()(flag, enabled)
    }

    pub unsafe fn all_enabled(&self, count: *mut u32) -> *const tm_strhash_t {
        ((*self.0).all_enabled).unsafe_unwrap()(count)
    }
}

impl crate::Api for FeatureFlagsApi {
    const NAME: *const i8 = TM_FEATURE_FLAGS_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_feature_flags_api)
    }
}
unsafe impl Send for FeatureFlagsApi {}
unsafe impl Sync for FeatureFlagsApi {}
pub struct GitIgnoreApi(pub *const tm_git_ignore_api);

impl GitIgnoreApi {
    pub unsafe fn match_(&self, patterns: &std::ffi::CStr, path: &std::ffi::CStr) -> bool {
        let patterns = patterns.as_ptr();
        let path = path.as_ptr();
        ((*self.0).match_).unsafe_unwrap()(patterns, path)
    }
}

impl crate::Api for GitIgnoreApi {
    const NAME: *const i8 = TM_GIT_IGNORE_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_git_ignore_api)
    }
}
unsafe impl Send for GitIgnoreApi {}
unsafe impl Sync for GitIgnoreApi {}
pub struct ImageLoaderApi(pub *const tm_image_loader_api);

impl ImageLoaderApi {
    pub unsafe fn add_loader(&self, loader: *mut tm_image_loader_i) {
        ((*self.0).add_loader).unsafe_unwrap()(loader)
    }

    pub unsafe fn remove_loader(&self, loader: *mut tm_image_loader_i) {
        ((*self.0).remove_loader).unsafe_unwrap()(loader)
    }

    pub unsafe fn loader_from_archive(
        &self,
        image_archive: *mut tm_image_archive_i,
    ) -> *mut tm_image_loader_i {
        ((*self.0).loader_from_archive).unsafe_unwrap()(image_archive)
    }

    pub unsafe fn loader_from_extension(
        &self,
        extension: &std::ffi::CStr,
    ) -> *mut tm_image_loader_i {
        let extension = extension.as_ptr();
        ((*self.0).loader_from_extension).unsafe_unwrap()(extension)
    }

    pub unsafe fn loaders(&self, loaders: *mut *mut tm_image_loader_i) -> u32 {
        ((*self.0).loaders).unsafe_unwrap()(loaders)
    }
}

impl crate::Api for ImageLoaderApi {
    const NAME: *const i8 = TM_IMAGE_LOADER_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_image_loader_api)
    }
}
unsafe impl Send for ImageLoaderApi {}
unsafe impl Sync for ImageLoaderApi {}
pub struct InputApi(pub *const tm_input_api);

impl InputApi {
    pub unsafe fn add_source(&self, source: *mut tm_input_source_i) {
        ((*self.0).add_source).unsafe_unwrap()(source)
    }

    pub unsafe fn remove_source(&self, source: *mut tm_input_source_i) {
        ((*self.0).remove_source).unsafe_unwrap()(source)
    }

    pub unsafe fn sources(&self, sources: *mut *mut *mut tm_input_source_i) -> u32 {
        ((*self.0).sources).unsafe_unwrap()(sources)
    }

    pub unsafe fn events(
        &self,
        start: u64,
        events: *mut tm_input_event_t,
        buffer_size: u64,
    ) -> u64 {
        ((*self.0).events).unsafe_unwrap()(start, events, buffer_size)
    }

    pub unsafe fn keyboard_item_names(&self) -> *mut *const ::std::os::raw::c_char {
        ((*self.0).keyboard_item_names).unsafe_unwrap()()
    }
}

impl crate::Api for InputApi {
    const NAME: *const i8 = TM_INPUT_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_input_api)
    }
}
unsafe impl Send for InputApi {}
unsafe impl Sync for InputApi {}
pub struct JobSystemApi(pub *const tm_job_system_api);

impl JobSystemApi {
    pub unsafe fn run_jobs(
        &self,
        jobs: *mut tm_jobdecl_t,
        num_jobs: u32,
    ) -> *mut tm_atomic_counter_o {
        ((*self.0).run_jobs).unsafe_unwrap()(jobs, num_jobs)
    }

    pub unsafe fn run_jobs_and_auto_free_counter(&self, jobs: *mut tm_jobdecl_t, num_jobs: u32) {
        ((*self.0).run_jobs_and_auto_free_counter).unsafe_unwrap()(jobs, num_jobs)
    }

    pub unsafe fn wait_for_counter(&self, counter: *mut tm_atomic_counter_o, value: u32) {
        ((*self.0).wait_for_counter).unsafe_unwrap()(counter, value)
    }

    pub unsafe fn wait_for_counter_and_free(&self, counter: *mut tm_atomic_counter_o) {
        ((*self.0).wait_for_counter_and_free).unsafe_unwrap()(counter)
    }

    pub unsafe fn wait_for_counter_and_free_no_fiber(&self, counter: *mut tm_atomic_counter_o) {
        ((*self.0).wait_for_counter_and_free_no_fiber).unsafe_unwrap()(counter)
    }

    pub unsafe fn pin_thread_handle(&self, worker_thread_index: u32) -> u32 {
        ((*self.0).pin_thread_handle).unsafe_unwrap()(worker_thread_index)
    }

    pub unsafe fn num_worker_threads(&self) -> u32 {
        ((*self.0).num_worker_threads).unsafe_unwrap()()
    }
}

impl crate::Api for JobSystemApi {
    const NAME: *const i8 = TM_JOB_SYSTEM_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_job_system_api)
    }
}
unsafe impl Send for JobSystemApi {}
unsafe impl Sync for JobSystemApi {}
pub struct JsonApi(pub *const tm_json_api);

impl JsonApi {
    pub unsafe fn parse(
        &self,
        s: &std::ffi::CStr,
        config: *mut tm_config_i,
        extensions: tm_json_parse_ext,
        error: *mut ::std::os::raw::c_char,
    ) -> bool {
        let s = s.as_ptr();
        ((*self.0).parse).unsafe_unwrap()(s, config, extensions, error)
    }

    pub unsafe fn parse_with_line_info(
        &self,
        s: &std::ffi::CStr,
        config: *mut tm_config_i,
        extensions: tm_json_parse_ext,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_json_parse_info_t {
        let s = s.as_ptr();
        ((*self.0).parse_with_line_info).unsafe_unwrap()(s, config, extensions, ta)
    }

    pub unsafe fn line_number(
        &self,
        pi: *const tm_json_parse_info_t,
        item: *const tm_config_item_t,
    ) -> u32 {
        ((*self.0).line_number).unsafe_unwrap()(pi, item)
    }

    pub unsafe fn generate(
        &self,
        config: *mut tm_config_i,
        flags: tm_json_generate_ext,
        ta: *mut tm_temp_allocator_i,
    ) -> tm_json_generate_t {
        ((*self.0).generate).unsafe_unwrap()(config, flags, ta)
    }
}

impl crate::Api for JsonApi {
    const NAME: *const i8 = TM_JSON_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_json_api)
    }
}
unsafe impl Send for JsonApi {}
unsafe impl Sync for JsonApi {}
pub struct LocalizerApi(pub *const tm_localizer_api);

impl LocalizerApi {}

impl crate::Api for LocalizerApi {
    const NAME: *const i8 = TM_LOCALIZER_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_localizer_api)
    }
}
unsafe impl Send for LocalizerApi {}
unsafe impl Sync for LocalizerApi {}
pub struct LoggerApi(pub *const tm_logger_api);

impl LoggerApi {
    pub unsafe fn add_logger(&self, logger: *const tm_logger_i) {
        ((*self.0).add_logger).unsafe_unwrap()(logger)
    }

    pub unsafe fn remove_logger(&self, logger: *const tm_logger_i) {
        ((*self.0).remove_logger).unsafe_unwrap()(logger)
    }

    pub unsafe fn print(&self, log_type: tm_log_type, msg: &std::ffi::CStr) {
        let msg = msg.as_ptr();
        ((*self.0).print).unsafe_unwrap()(log_type, msg)
    }

    pub unsafe fn printf(
        &self,
        log_type: tm_log_type,
        format: &std::ffi::CStr,
    ) -> ::std::os::raw::c_int {
        let format = format.as_ptr();
        ((*self.0).printf).unsafe_unwrap()(log_type, format)
    }
}

impl crate::Api for LoggerApi {
    const NAME: *const i8 = TM_LOGGER_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_logger_api)
    }
}
unsafe impl Send for LoggerApi {}
unsafe impl Sync for LoggerApi {}
pub struct Lz4Api(pub *const tm_lz4_api);

impl Lz4Api {
    pub unsafe fn compress(
        &self,
        src: &std::ffi::CStr,
        src_size: u32,
        dst: *mut ::std::os::raw::c_char,
        dst_capacity: u32,
    ) -> u32 {
        let src = src.as_ptr();
        ((*self.0).compress).unsafe_unwrap()(src, src_size, dst, dst_capacity)
    }

    pub unsafe fn decompress(
        &self,
        src: &std::ffi::CStr,
        src_size: u32,
        dst: *mut ::std::os::raw::c_char,
        dst_capacity: u32,
    ) -> u32 {
        let src = src.as_ptr();
        ((*self.0).decompress).unsafe_unwrap()(src, src_size, dst, dst_capacity)
    }

    pub unsafe fn compress_bound(&self, src_size: u32) -> u32 {
        ((*self.0).compress_bound).unsafe_unwrap()(src_size)
    }
}

impl crate::Api for Lz4Api {
    const NAME: *const i8 = TM_LZ4_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_lz4_api)
    }
}
unsafe impl Send for Lz4Api {}
unsafe impl Sync for Lz4Api {}
pub struct MathApi(pub *const tm_math_api);

impl MathApi {
    pub unsafe fn mat44_multiply(
        &self,
        res: *mut tm_mat44_t,
        lhs: *const tm_mat44_t,
        rhs: *const tm_mat44_t,
    ) {
        ((*self.0).mat44_multiply).unsafe_unwrap()(res, lhs, rhs)
    }

    pub unsafe fn mat44_inverse(&self, res: *mut tm_mat44_t, m: *const tm_mat44_t) {
        ((*self.0).mat44_inverse).unsafe_unwrap()(res, m)
    }

    pub unsafe fn mat44_determinant(&self, m: *const tm_mat44_t) -> f32 {
        ((*self.0).mat44_determinant).unsafe_unwrap()(m)
    }

    pub unsafe fn mat44_determinant33(&self, m: *const tm_mat44_t) -> f32 {
        ((*self.0).mat44_determinant33).unsafe_unwrap()(m)
    }

    pub unsafe fn mat44_to_quaternion(&self, m: *const tm_mat44_t) -> tm_vec4_t {
        ((*self.0).mat44_to_quaternion).unsafe_unwrap()(m)
    }

    pub unsafe fn mat44_to_translation_quaternion_scale(
        &self,
        t: *mut tm_vec3_t,
        r: *mut tm_vec4_t,
        s: *mut tm_vec3_t,
        m: *const tm_mat44_t,
    ) {
        ((*self.0).mat44_to_translation_quaternion_scale).unsafe_unwrap()(t, r, s, m)
    }
}

impl crate::Api for MathApi {
    const NAME: *const i8 = TM_MATH_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_math_api)
    }
}
unsafe impl Send for MathApi {}
unsafe impl Sync for MathApi {}
pub struct MemoryTrackerApi(pub *const tm_memory_tracker_api);

impl MemoryTrackerApi {
    pub unsafe fn check_for_leaked_scopes(&self) {
        ((*self.0).check_for_leaked_scopes).unsafe_unwrap()()
    }

    pub unsafe fn create_scope(&self, desc: &std::ffi::CStr, parent_scope: u32) -> u32 {
        let desc = desc.as_ptr();
        ((*self.0).create_scope).unsafe_unwrap()(desc, parent_scope)
    }

    pub unsafe fn destroy_scope(&self, s: u32) {
        ((*self.0).destroy_scope).unsafe_unwrap()(s)
    }

    pub unsafe fn destroy_scope_allowing_leaks(&self, scope: u32, max_leaked_bytes: u64) {
        ((*self.0).destroy_scope_allowing_leaks).unsafe_unwrap()(scope, max_leaked_bytes)
    }

    pub unsafe fn record_realloc(
        &self,
        old_ptr: *mut ::std::os::raw::c_void,
        old_size: u64,
        new_ptr: *mut ::std::os::raw::c_void,
        new_size: u64,
        file: &std::ffi::CStr,
        line: u32,
        scope: u32,
    ) {
        let file = file.as_ptr();
        ((*self.0).record_realloc).unsafe_unwrap()(
            old_ptr, old_size, new_ptr, new_size, file, line, scope,
        )
    }

    pub unsafe fn allocated_bytes(&self, scope: u32) -> u64 {
        ((*self.0).allocated_bytes).unsafe_unwrap()(scope)
    }

    pub unsafe fn allocation_count(&self, scope: u32) -> u64 {
        ((*self.0).allocation_count).unsafe_unwrap()(scope)
    }

    pub unsafe fn set_scope_tracing(&self, scope: u32, enabled: bool) {
        ((*self.0).set_scope_tracing).unsafe_unwrap()(scope, enabled)
    }

    pub unsafe fn scope_data_snapshot(
        &self,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_memory_tracker_scope_data_t {
        ((*self.0).scope_data_snapshot).unsafe_unwrap()(ta)
    }

    pub unsafe fn trace_data_snapshot(
        &self,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_memory_tracker_trace_data_t {
        ((*self.0).trace_data_snapshot).unsafe_unwrap()(ta)
    }
}

impl crate::Api for MemoryTrackerApi {
    const NAME: *const i8 = TM_MEMORY_TRACKER_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_memory_tracker_api)
    }
}
unsafe impl Send for MemoryTrackerApi {}
unsafe impl Sync for MemoryTrackerApi {}
pub struct OsVirtualMemoryApi(pub *const tm_os_virtual_memory_api);

impl OsVirtualMemoryApi {
    pub unsafe fn map(&self, size: u64) -> *mut ::std::os::raw::c_void {
        ((*self.0).map).unsafe_unwrap()(size)
    }

    pub unsafe fn unmap(&self, p: *mut ::std::os::raw::c_void, size: u64) {
        ((*self.0).unmap).unsafe_unwrap()(p, size)
    }

    pub unsafe fn reserve(&self, size: u64) -> *mut ::std::os::raw::c_void {
        ((*self.0).reserve).unsafe_unwrap()(size)
    }

    pub unsafe fn commit(&self, p: *mut ::std::os::raw::c_void, size: u64) {
        ((*self.0).commit).unsafe_unwrap()(p, size)
    }
}

unsafe impl Send for OsVirtualMemoryApi {}
unsafe impl Sync for OsVirtualMemoryApi {}
pub struct OsFileIoApi(pub *const tm_os_file_io_api);

impl OsFileIoApi {
    pub unsafe fn open_input(&self, path: &std::ffi::CStr) -> tm_file_o {
        let path = path.as_ptr();
        ((*self.0).open_input).unsafe_unwrap()(path)
    }

    pub unsafe fn open_output(&self, path: &std::ffi::CStr) -> tm_file_o {
        let path = path.as_ptr();
        ((*self.0).open_output).unsafe_unwrap()(path)
    }

    pub unsafe fn open_append(&self, path: &std::ffi::CStr) -> tm_file_o {
        let path = path.as_ptr();
        ((*self.0).open_append).unsafe_unwrap()(path)
    }

    pub unsafe fn set_position(&self, file: tm_file_o, pos: u64) {
        ((*self.0).set_position).unsafe_unwrap()(file, pos)
    }

    pub unsafe fn size(&self, file: tm_file_o) -> u64 {
        ((*self.0).size).unsafe_unwrap()(file)
    }

    pub unsafe fn read(
        &self,
        file: tm_file_o,
        buffer: *mut ::std::os::raw::c_void,
        size: u64,
    ) -> i64 {
        ((*self.0).read).unsafe_unwrap()(file, buffer, size)
    }

    pub unsafe fn write(
        &self,
        file: tm_file_o,
        buffer: *const ::std::os::raw::c_void,
        size: u64,
    ) -> bool {
        ((*self.0).write).unsafe_unwrap()(file, buffer, size)
    }

    pub unsafe fn read_at(
        &self,
        file: tm_file_o,
        offset: u64,
        buffer: *mut ::std::os::raw::c_void,
        size: u64,
    ) -> i64 {
        ((*self.0).read_at).unsafe_unwrap()(file, offset, buffer, size)
    }

    pub unsafe fn write_at(
        &self,
        file: tm_file_o,
        offset: u64,
        buffer: *const ::std::os::raw::c_void,
        size: u64,
    ) -> bool {
        ((*self.0).write_at).unsafe_unwrap()(file, offset, buffer, size)
    }

    pub unsafe fn set_last_modified_time(&self, file: tm_file_o, time: tm_file_time_o) {
        ((*self.0).set_last_modified_time).unsafe_unwrap()(file, time)
    }

    pub unsafe fn close(&self, file: tm_file_o) {
        ((*self.0).close).unsafe_unwrap()(file)
    }
}

unsafe impl Send for OsFileIoApi {}
unsafe impl Sync for OsFileIoApi {}
pub struct OsFileSystemApi(pub *const tm_os_file_system_api);

impl OsFileSystemApi {
    pub unsafe fn stat(&self, path: &std::ffi::CStr) -> tm_file_stat_t {
        let path = path.as_ptr();
        ((*self.0).stat).unsafe_unwrap()(path)
    }

    pub unsafe fn directory_entries(
        &self,
        path: &std::ffi::CStr,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_strings_t {
        let path = path.as_ptr();
        ((*self.0).directory_entries).unsafe_unwrap()(path, ta)
    }

    pub unsafe fn make_directory(&self, path: &std::ffi::CStr) -> bool {
        let path = path.as_ptr();
        ((*self.0).make_directory).unsafe_unwrap()(path)
    }

    pub unsafe fn remove_file(&self, path: &std::ffi::CStr) -> bool {
        let path = path.as_ptr();
        ((*self.0).remove_file).unsafe_unwrap()(path)
    }

    pub unsafe fn remove_directory(&self, path: &std::ffi::CStr) -> bool {
        let path = path.as_ptr();
        ((*self.0).remove_directory).unsafe_unwrap()(path)
    }

    pub unsafe fn rename(&self, old_name: &std::ffi::CStr, new_name: &std::ffi::CStr) -> bool {
        let old_name = old_name.as_ptr();
        let new_name = new_name.as_ptr();
        ((*self.0).rename).unsafe_unwrap()(old_name, new_name)
    }

    pub unsafe fn copy_file(&self, from: &std::ffi::CStr, to: &std::ffi::CStr) -> bool {
        let from = from.as_ptr();
        let to = to.as_ptr();
        ((*self.0).copy_file).unsafe_unwrap()(from, to)
    }

    pub unsafe fn getcwd(&self, ta: *mut tm_temp_allocator_i) -> *const ::std::os::raw::c_char {
        ((*self.0).getcwd).unsafe_unwrap()(ta)
    }

    pub unsafe fn chdir(&self, path: &std::ffi::CStr) -> bool {
        let path = path.as_ptr();
        ((*self.0).chdir).unsafe_unwrap()(path)
    }

    pub unsafe fn is_absolute(&self, path: &std::ffi::CStr) -> bool {
        let path = path.as_ptr();
        ((*self.0).is_absolute).unsafe_unwrap()(path)
    }

    pub unsafe fn absolute(
        &self,
        path: &std::ffi::CStr,
        ta: *mut tm_temp_allocator_i,
    ) -> *const ::std::os::raw::c_char {
        let path = path.as_ptr();
        ((*self.0).absolute).unsafe_unwrap()(path, ta)
    }

    pub unsafe fn temp_directory(
        &self,
        ta: *mut tm_temp_allocator_i,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).temp_directory).unsafe_unwrap()(ta)
    }

    pub unsafe fn create_watcher(&self, subtree_path: &std::ffi::CStr) -> tm_file_system_watcher_o {
        let subtree_path = subtree_path.as_ptr();
        ((*self.0).create_watcher).unsafe_unwrap()(subtree_path)
    }

    pub unsafe fn any_changes(&self, watcher: tm_file_system_watcher_o) -> bool {
        ((*self.0).any_changes).unsafe_unwrap()(watcher)
    }

    pub unsafe fn destroy_watcher(&self, watcher: tm_file_system_watcher_o) {
        ((*self.0).destroy_watcher).unsafe_unwrap()(watcher)
    }

    pub unsafe fn create_detailed_watcher(
        &self,
        subtree_path: &std::ffi::CStr,
    ) -> *mut tm_file_system_detailed_watcher_o {
        let subtree_path = subtree_path.as_ptr();
        ((*self.0).create_detailed_watcher).unsafe_unwrap()(subtree_path)
    }

    pub unsafe fn detailed_changes(
        &self,
        arg1: *mut tm_file_system_detailed_watcher_o,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_file_system_change_t {
        ((*self.0).detailed_changes).unsafe_unwrap()(arg1, ta)
    }

    pub unsafe fn destroy_detailed_watcher(&self, watcher: *mut tm_file_system_detailed_watcher_o) {
        ((*self.0).destroy_detailed_watcher).unsafe_unwrap()(watcher)
    }

    pub unsafe fn app_folder(&self, ta: *mut tm_temp_allocator_i) -> *const ::std::os::raw::c_char {
        ((*self.0).app_folder).unsafe_unwrap()(ta)
    }
}

unsafe impl Send for OsFileSystemApi {}
unsafe impl Sync for OsFileSystemApi {}
pub struct OsDllApi(pub *const tm_os_dll_api);

impl OsDllApi {
    pub unsafe fn open(&self, path: &std::ffi::CStr) -> tm_dll_o {
        let path = path.as_ptr();
        ((*self.0).open).unsafe_unwrap()(path)
    }

    pub unsafe fn get(&self, path: &std::ffi::CStr) -> tm_dll_o {
        let path = path.as_ptr();
        ((*self.0).get).unsafe_unwrap()(path)
    }

    pub unsafe fn sym(
        &self,
        handle: tm_dll_o,
        name: &std::ffi::CStr,
    ) -> *mut ::std::os::raw::c_void {
        let name = name.as_ptr();
        ((*self.0).sym).unsafe_unwrap()(handle, name)
    }

    pub unsafe fn close(&self, handle: tm_dll_o) {
        ((*self.0).close).unsafe_unwrap()(handle)
    }
}

unsafe impl Send for OsDllApi {}
unsafe impl Sync for OsDllApi {}
pub struct OsSocketApi(pub *const tm_os_socket_api);

impl OsSocketApi {
    pub unsafe fn init(&self) {
        ((*self.0).init).unsafe_unwrap()()
    }

    pub unsafe fn shutdown(&self) {
        ((*self.0).shutdown).unsafe_unwrap()()
    }

    pub unsafe fn socket(&self, type_: tm_os_socket_type) -> tm_socket_o {
        ((*self.0).socket).unsafe_unwrap()(type_)
    }

    pub unsafe fn set_option(
        &self,
        socket: tm_socket_o,
        option: tm_os_socket_option,
        enabled: bool,
    ) {
        ((*self.0).set_option).unsafe_unwrap()(socket, option, enabled)
    }

    pub unsafe fn bind(&self, socket: tm_socket_o, address: tm_socket_address_t) -> bool {
        ((*self.0).bind).unsafe_unwrap()(socket, address)
    }

    pub unsafe fn getsockname(
        &self,
        socket: tm_socket_o,
        address: *mut tm_socket_address_t,
    ) -> bool {
        ((*self.0).getsockname).unsafe_unwrap()(socket, address)
    }

    pub unsafe fn listen(&self, socket: tm_socket_o, queue_size: u32) -> bool {
        ((*self.0).listen).unsafe_unwrap()(socket, queue_size)
    }

    pub unsafe fn accept(
        &self,
        socket: tm_socket_o,
        address: *mut tm_socket_address_t,
    ) -> tm_socket_o {
        ((*self.0).accept).unsafe_unwrap()(socket, address)
    }

    pub unsafe fn connect(
        &self,
        socket: tm_socket_o,
        target: tm_socket_address_t,
    ) -> tm_os_socket_connect {
        ((*self.0).connect).unsafe_unwrap()(socket, target)
    }

    pub unsafe fn send(
        &self,
        socket: tm_socket_o,
        buffer: *const ::std::os::raw::c_void,
        size: u32,
    ) -> i32 {
        ((*self.0).send).unsafe_unwrap()(socket, buffer, size)
    }

    pub unsafe fn recv(
        &self,
        socket: tm_socket_o,
        buffer: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> i32 {
        ((*self.0).recv).unsafe_unwrap()(socket, buffer, size)
    }

    pub unsafe fn sendto(
        &self,
        socket: tm_socket_o,
        buffer: *const ::std::os::raw::c_void,
        size: u32,
        target: tm_socket_address_t,
    ) -> i32 {
        ((*self.0).sendto).unsafe_unwrap()(socket, buffer, size, target)
    }

    pub unsafe fn recvfrom(
        &self,
        socket: tm_socket_o,
        buffer: *mut ::std::os::raw::c_void,
        size: u32,
        source: *mut tm_socket_address_t,
    ) -> i32 {
        ((*self.0).recvfrom).unsafe_unwrap()(socket, buffer, size, source)
    }

    pub unsafe fn close(&self, socket: tm_socket_o) -> bool {
        ((*self.0).close).unsafe_unwrap()(socket)
    }

    pub unsafe fn getaddrinfo(
        &self,
        name: &std::ffi::CStr,
        service: &std::ffi::CStr,
        addresses: *mut tm_socket_address_t,
        size: u32,
    ) -> u32 {
        let name = name.as_ptr();
        let service = service.as_ptr();
        ((*self.0).getaddrinfo).unsafe_unwrap()(name, service, addresses, size)
    }

    pub unsafe fn getaddrinfo_async(
        &self,
        name: &std::ffi::CStr,
        service: &std::ffi::CStr,
    ) -> *mut ::std::os::raw::c_void {
        let name = name.as_ptr();
        let service = service.as_ptr();
        ((*self.0).getaddrinfo_async).unsafe_unwrap()(name, service)
    }

    pub unsafe fn getaddrinfo_result(
        &self,
        query: *mut ::std::os::raw::c_void,
        addresses: *mut tm_socket_address_t,
        count: *mut u32,
    ) -> tm_os_socket_getaddrinfo {
        ((*self.0).getaddrinfo_result).unsafe_unwrap()(query, addresses, count)
    }
}

unsafe impl Send for OsSocketApi {}
unsafe impl Sync for OsSocketApi {}
pub struct OsThreadApi(pub *const tm_os_thread_api);

impl OsThreadApi {
    pub unsafe fn create_critical_section(&self, cs: *mut tm_critical_section_o) {
        ((*self.0).create_critical_section).unsafe_unwrap()(cs)
    }

    pub unsafe fn enter_critical_section(&self, cs: *mut tm_critical_section_o) {
        ((*self.0).enter_critical_section).unsafe_unwrap()(cs)
    }

    pub unsafe fn leave_critical_section(&self, cs: *mut tm_critical_section_o) {
        ((*self.0).leave_critical_section).unsafe_unwrap()(cs)
    }

    pub unsafe fn destroy_critical_section(&self, cs: *mut tm_critical_section_o) {
        ((*self.0).destroy_critical_section).unsafe_unwrap()(cs)
    }

    pub unsafe fn create_semaphore(&self, initial_count: u32) -> tm_semaphore_o {
        ((*self.0).create_semaphore).unsafe_unwrap()(initial_count)
    }

    pub unsafe fn semaphore_add(&self, sem: tm_semaphore_o, count: u32) {
        ((*self.0).semaphore_add).unsafe_unwrap()(sem, count)
    }

    pub unsafe fn semaphore_wait(&self, sem: tm_semaphore_o) {
        ((*self.0).semaphore_wait).unsafe_unwrap()(sem)
    }

    pub unsafe fn semaphore_poll(&self, sem: tm_semaphore_o) -> bool {
        ((*self.0).semaphore_poll).unsafe_unwrap()(sem)
    }

    pub unsafe fn destroy_semaphore(&self, sem: tm_semaphore_o) {
        ((*self.0).destroy_semaphore).unsafe_unwrap()(sem)
    }

    pub unsafe fn thread_id(&self) -> u32 {
        ((*self.0).thread_id).unsafe_unwrap()()
    }

    pub unsafe fn processor_id(&self) -> u32 {
        ((*self.0).processor_id).unsafe_unwrap()()
    }

    pub unsafe fn create_thread(
        &self,
        entry: tm_thread_entry_f,
        user_data: *mut ::std::os::raw::c_void,
        stack_size: u32,
        debug_name: &std::ffi::CStr,
    ) -> tm_thread_o {
        let debug_name = debug_name.as_ptr();
        ((*self.0).create_thread).unsafe_unwrap()(entry, user_data, stack_size, debug_name)
    }

    pub unsafe fn set_thread_priority(
        &self,
        thread: tm_thread_o,
        priority: tm_os_thread__priority,
    ) {
        ((*self.0).set_thread_priority).unsafe_unwrap()(thread, priority)
    }

    pub unsafe fn wait_for_thread(&self, thread: tm_thread_o) {
        ((*self.0).wait_for_thread).unsafe_unwrap()(thread)
    }

    pub unsafe fn thread_id_from_tm_thread(&self, thread: tm_thread_o) -> u32 {
        ((*self.0).thread_id_from_tm_thread).unsafe_unwrap()(thread)
    }

    pub unsafe fn convert_thread_to_fiber(
        &self,
        user_data: *mut ::std::os::raw::c_void,
    ) -> tm_fiber_o {
        ((*self.0).convert_thread_to_fiber).unsafe_unwrap()(user_data)
    }

    pub unsafe fn convert_fiber_to_thread(&self) {
        ((*self.0).convert_fiber_to_thread).unsafe_unwrap()()
    }

    pub unsafe fn create_fiber(
        &self,
        entry: tm_fiber_entry_f,
        user_data: *mut ::std::os::raw::c_void,
        stack_size: u32,
    ) -> tm_fiber_o {
        ((*self.0).create_fiber).unsafe_unwrap()(entry, user_data, stack_size)
    }

    pub unsafe fn destroy_fiber(&self, fiber: tm_fiber_o) {
        ((*self.0).destroy_fiber).unsafe_unwrap()(fiber)
    }

    pub unsafe fn switch_to_fiber(&self, fiber: tm_fiber_o) {
        ((*self.0).switch_to_fiber).unsafe_unwrap()(fiber)
    }

    pub unsafe fn fiber_user_data(&self) -> *mut ::std::os::raw::c_void {
        ((*self.0).fiber_user_data).unsafe_unwrap()()
    }

    pub unsafe fn yield_processor(&self) {
        ((*self.0).yield_processor).unsafe_unwrap()()
    }

    pub unsafe fn sleep(&self, seconds: f64) {
        ((*self.0).sleep).unsafe_unwrap()(seconds)
    }
}

unsafe impl Send for OsThreadApi {}
unsafe impl Sync for OsThreadApi {}
pub struct OsTimeApi(pub *const tm_os_time_api);

impl OsTimeApi {
    pub unsafe fn now(&self) -> tm_clock_o {
        ((*self.0).now).unsafe_unwrap()()
    }

    pub unsafe fn delta(&self, to: tm_clock_o, from: tm_clock_o) -> f64 {
        ((*self.0).delta).unsafe_unwrap()(to, from)
    }

    pub unsafe fn add(&self, from: tm_clock_o, delta: f64) -> tm_clock_o {
        ((*self.0).add).unsafe_unwrap()(from, delta)
    }

    pub unsafe fn file_time_now(&self) -> tm_file_time_o {
        ((*self.0).file_time_now).unsafe_unwrap()()
    }

    pub unsafe fn file_time_delta(&self, to: tm_file_time_o, from: tm_file_time_o) -> f64 {
        ((*self.0).file_time_delta).unsafe_unwrap()(to, from)
    }
}

unsafe impl Send for OsTimeApi {}
unsafe impl Sync for OsTimeApi {}
pub struct OsDialogsApi(pub *const tm_os_dialogs_api);

impl OsDialogsApi {
    pub unsafe fn open(
        &self,
        s: *const tm_os_dialogs_open_t,
        ta: *mut tm_temp_allocator_i,
    ) -> tm_os_dialogs_open_res_t {
        ((*self.0).open).unsafe_unwrap()(s, ta)
    }

    pub unsafe fn open_folder(&self, ta: *mut tm_temp_allocator_i) -> *mut ::std::os::raw::c_char {
        ((*self.0).open_folder).unsafe_unwrap()(ta)
    }

    pub unsafe fn save(
        &self,
        s: *const tm_os_dialogs_save_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut ::std::os::raw::c_char {
        ((*self.0).save).unsafe_unwrap()(s, ta)
    }

    pub unsafe fn message_box(&self, title: &std::ffi::CStr, text: &std::ffi::CStr) {
        let title = title.as_ptr();
        let text = text.as_ptr();
        ((*self.0).message_box).unsafe_unwrap()(title, text)
    }

    pub unsafe fn show_count(&self) -> u64 {
        ((*self.0).show_count).unsafe_unwrap()()
    }
}

unsafe impl Send for OsDialogsApi {}
unsafe impl Sync for OsDialogsApi {}
pub struct OsInfoApi(pub *const tm_os_info_api);

impl OsInfoApi {
    pub unsafe fn num_logical_processors(&self) -> u32 {
        ((*self.0).num_logical_processors).unsafe_unwrap()()
    }

    pub unsafe fn avx_support(&self) -> bool {
        ((*self.0).avx_support).unsafe_unwrap()()
    }
}

unsafe impl Send for OsInfoApi {}
unsafe impl Sync for OsInfoApi {}
pub struct OsDebuggerApi(pub *const tm_os_debugger_api);

impl OsDebuggerApi {
    pub unsafe fn is_debugger_present(&self) -> bool {
        ((*self.0).is_debugger_present).unsafe_unwrap()()
    }

    pub unsafe fn debug_break(&self) {
        ((*self.0).debug_break).unsafe_unwrap()()
    }
}

unsafe impl Send for OsDebuggerApi {}
unsafe impl Sync for OsDebuggerApi {}
pub struct OsSystemApi(pub *const tm_os_system_api);

impl OsSystemApi {
    pub unsafe fn open_url(&self, url: &std::ffi::CStr) {
        let url = url.as_ptr();
        ((*self.0).open_url).unsafe_unwrap()(url)
    }

    pub unsafe fn open_file(&self, file: &std::ffi::CStr) -> bool {
        let file = file.as_ptr();
        ((*self.0).open_file).unsafe_unwrap()(file)
    }

    pub unsafe fn exe_path(&self, argv_0: &std::ffi::CStr) -> *const ::std::os::raw::c_char {
        let argv_0 = argv_0.as_ptr();
        ((*self.0).exe_path).unsafe_unwrap()(argv_0)
    }

    pub unsafe fn execute(&self, command: &std::ffi::CStr) -> ::std::os::raw::c_int {
        let command = command.as_ptr();
        ((*self.0).execute).unsafe_unwrap()(command)
    }

    pub unsafe fn execute_in_background(&self, command: &std::ffi::CStr) -> ::std::os::raw::c_int {
        let command = command.as_ptr();
        ((*self.0).execute_in_background).unsafe_unwrap()(command)
    }

    pub unsafe fn execute_stdout(
        &self,
        command: &std::ffi::CStr,
        timeout_ms: u32,
        ta: *mut tm_temp_allocator_i,
        exit_code: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        let command = command.as_ptr();
        ((*self.0).execute_stdout).unsafe_unwrap()(command, timeout_ms, ta, exit_code)
    }
}

unsafe impl Send for OsSystemApi {}
unsafe impl Sync for OsSystemApi {}
pub struct OsApi(pub *const tm_os_api);

impl OsApi {}

impl crate::Api for OsApi {
    const NAME: *const i8 = TM_OS_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_os_api)
    }
}
unsafe impl Send for OsApi {}
unsafe impl Sync for OsApi {}
pub struct PathApi(pub *const tm_path_api);

impl PathApi {
    pub unsafe fn extension(&self, path: tm_str_t) -> tm_str_t {
        ((*self.0).extension).unsafe_unwrap()(path)
    }

    pub unsafe fn extension_cstr(&self, path: &std::ffi::CStr) -> *const ::std::os::raw::c_char {
        let path = path.as_ptr();
        ((*self.0).extension_cstr).unsafe_unwrap()(path)
    }

    pub unsafe fn strip_extension(&self, path: tm_str_t) -> tm_str_t {
        ((*self.0).strip_extension).unsafe_unwrap()(path)
    }

    pub unsafe fn base(&self, path: tm_str_t) -> tm_str_t {
        ((*self.0).base).unsafe_unwrap()(path)
    }

    pub unsafe fn base_cstr(&self, path: &std::ffi::CStr) -> *const ::std::os::raw::c_char {
        let path = path.as_ptr();
        ((*self.0).base_cstr).unsafe_unwrap()(path)
    }

    pub unsafe fn directory(&self, path: tm_str_t) -> tm_str_t {
        ((*self.0).directory).unsafe_unwrap()(path)
    }

    pub unsafe fn pop_last(&self, path: *mut tm_str_t) -> tm_str_t {
        ((*self.0).pop_last).unsafe_unwrap()(path)
    }

    pub unsafe fn pop_first(&self, path: *mut tm_str_t) -> tm_str_t {
        ((*self.0).pop_first).unsafe_unwrap()(path)
    }

    pub unsafe fn split_all(&self, path: tm_str_t, ta: *mut tm_temp_allocator_i) -> *mut tm_str_t {
        ((*self.0).split_all).unsafe_unwrap()(path, ta)
    }

    pub unsafe fn join(&self, a: tm_str_t, b: tm_str_t, ta: *mut tm_temp_allocator_i) -> tm_str_t {
        ((*self.0).join).unsafe_unwrap()(a, b, ta)
    }
}

impl crate::Api for PathApi {
    const NAME: *const i8 = TM_PATH_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_path_api)
    }
}
unsafe impl Send for PathApi {}
unsafe impl Sync for PathApi {}
pub struct PluginsApi(pub *const tm_plugins_api);

impl PluginsApi {
    pub unsafe fn load(&self, path: &std::ffi::CStr, hot_reload: bool) -> u64 {
        let path = path.as_ptr();
        ((*self.0).load).unsafe_unwrap()(path, hot_reload)
    }

    pub unsafe fn unload(&self, plugin: u64) {
        ((*self.0).unload).unsafe_unwrap()(plugin)
    }

    pub unsafe fn reload(&self, plugin: u64) {
        ((*self.0).reload).unsafe_unwrap()(plugin)
    }

    pub unsafe fn set_path(&self, plugin: u64, path: &std::ffi::CStr) {
        let path = path.as_ptr();
        ((*self.0).set_path).unsafe_unwrap()(plugin, path)
    }

    pub unsafe fn check_hot_reload(&self) -> bool {
        ((*self.0).check_hot_reload).unsafe_unwrap()()
    }

    pub unsafe fn reload_count(&self) -> u64 {
        ((*self.0).reload_count).unsafe_unwrap()()
    }

    pub unsafe fn enumerate(
        &self,
        directory: &std::ffi::CStr,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut *const ::std::os::raw::c_char {
        let directory = directory.as_ptr();
        ((*self.0).enumerate).unsafe_unwrap()(directory, ta)
    }

    pub unsafe fn load_plugin_context(&self) -> *const ::std::os::raw::c_char {
        ((*self.0).load_plugin_context).unsafe_unwrap()()
    }

    pub unsafe fn plugin_dllpath(
        &self,
        ta: *mut tm_temp_allocator_i,
        exe: &std::ffi::CStr,
        name: &std::ffi::CStr,
    ) -> *const ::std::os::raw::c_char {
        let exe = exe.as_ptr();
        let name = name.as_ptr();
        ((*self.0).plugin_dllpath).unsafe_unwrap()(ta, exe, name)
    }

    pub unsafe fn app_dllpath(
        &self,
        ta: *mut tm_temp_allocator_i,
        exe: &std::ffi::CStr,
        name: &std::ffi::CStr,
    ) -> *const ::std::os::raw::c_char {
        let exe = exe.as_ptr();
        let name = name.as_ptr();
        ((*self.0).app_dllpath).unsafe_unwrap()(ta, exe, name)
    }
}

impl crate::Api for PluginsApi {
    const NAME: *const i8 = TM_PLUGINS_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_plugins_api)
    }
}
unsafe impl Send for PluginsApi {}
unsafe impl Sync for PluginsApi {}
pub struct PluginAssetsApi(pub *const tm_plugin_assets_api);

impl PluginAssetsApi {
    pub unsafe fn any_plugins(&self, tt: *mut tm_the_truth_o) -> bool {
        ((*self.0).any_plugins).unsafe_unwrap()(tt)
    }

    pub unsafe fn init_truth(&self, tt: *mut tm_the_truth_o, allow_code_execution: bool) {
        ((*self.0).init_truth).unsafe_unwrap()(tt, allow_code_execution)
    }

    pub unsafe fn shutdown_truth(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).shutdown_truth).unsafe_unwrap()(tt)
    }

    pub unsafe fn update_truth(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).update_truth).unsafe_unwrap()(tt)
    }

    pub unsafe fn allow_code_execution(&self, tt: *mut tm_the_truth_o) -> bool {
        ((*self.0).allow_code_execution).unsafe_unwrap()(tt)
    }

    pub unsafe fn set_allow_code_execution(
        &self,
        tt: *mut tm_the_truth_o,
        allow_code_execution: bool,
    ) {
        ((*self.0).set_allow_code_execution).unsafe_unwrap()(tt, allow_code_execution)
    }
}

impl crate::Api for PluginAssetsApi {
    const NAME: *const i8 = TM_PLUGIN_ASSETS_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_plugin_assets_api)
    }
}
unsafe impl Send for PluginAssetsApi {}
unsafe impl Sync for PluginAssetsApi {}
pub struct ProfilerApi(pub *const tm_profiler_api);

impl ProfilerApi {
    pub unsafe fn init(&self, allocator: *mut tm_allocator_i, event_buffer_size: u32) {
        ((*self.0).init).unsafe_unwrap()(allocator, event_buffer_size)
    }

    pub unsafe fn shutdown(&self) {
        ((*self.0).shutdown).unsafe_unwrap()()
    }

    pub unsafe fn begin(
        &self,
        name: &std::ffi::CStr,
        category: &std::ffi::CStr,
        object: &std::ffi::CStr,
    ) -> u64 {
        let name = name.as_ptr();
        let category = category.as_ptr();
        let object = object.as_ptr();
        ((*self.0).begin).unsafe_unwrap()(name, category, object)
    }

    pub unsafe fn end(&self, begin_id: u64) {
        ((*self.0).end).unsafe_unwrap()(begin_id)
    }

    pub unsafe fn instant(
        &self,
        name: &std::ffi::CStr,
        category: &std::ffi::CStr,
        object: &std::ffi::CStr,
    ) {
        let name = name.as_ptr();
        let category = category.as_ptr();
        let object = object.as_ptr();
        ((*self.0).instant).unsafe_unwrap()(name, category, object)
    }

    pub unsafe fn start(
        &self,
        name: &std::ffi::CStr,
        category: &std::ffi::CStr,
        object: &std::ffi::CStr,
    ) -> u64 {
        let name = name.as_ptr();
        let category = category.as_ptr();
        let object = object.as_ptr();
        ((*self.0).start).unsafe_unwrap()(name, category, object)
    }

    pub unsafe fn finish(&self, start_id: u64) {
        ((*self.0).finish).unsafe_unwrap()(start_id)
    }

    pub unsafe fn intern(&self, s: &std::ffi::CStr) -> *const ::std::os::raw::c_char {
        let s = s.as_ptr();
        ((*self.0).intern).unsafe_unwrap()(s)
    }

    pub unsafe fn fiber_switch(&self, from_fiber: u32, to_fiber: u32) {
        ((*self.0).fiber_switch).unsafe_unwrap()(from_fiber, to_fiber)
    }

    pub unsafe fn submit(&self, events: *mut tm_profiler_event_t, count: u32) {
        ((*self.0).submit).unsafe_unwrap()(events, count)
    }

    pub unsafe fn copy(
        &self,
        dest: *mut tm_profiler_event_t,
        start: u64,
        count: u32,
        actual_start: *mut u64,
        actual_count: *mut u32,
    ) {
        ((*self.0).copy).unsafe_unwrap()(dest, start, count, actual_start, actual_count)
    }

    pub unsafe fn buffer(&self) -> tm_profiler_buffer_t {
        ((*self.0).buffer).unsafe_unwrap()()
    }
}

impl crate::Api for ProfilerApi {
    const NAME: *const i8 = TM_PROFILER_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_profiler_api)
    }
}
unsafe impl Send for ProfilerApi {}
unsafe impl Sync for ProfilerApi {}
pub struct ProgressReportApi(pub *const tm_progress_report_api);

impl ProgressReportApi {
    pub unsafe fn create(&self, a: *mut tm_allocator_i, task_display_time: f32) {
        ((*self.0).create).unsafe_unwrap()(a, task_display_time)
    }

    pub unsafe fn destroy(&self) {
        ((*self.0).destroy).unsafe_unwrap()()
    }

    pub unsafe fn update(&self, dt: f64, ta: *mut tm_temp_allocator_i) -> tm_task_progress_t {
        ((*self.0).update).unsafe_unwrap()(dt, ta)
    }

    pub unsafe fn status(&self, ta: *mut tm_temp_allocator_i) -> tm_task_status_t {
        ((*self.0).status).unsafe_unwrap()(ta)
    }

    pub unsafe fn idle(&self) -> bool {
        ((*self.0).idle).unsafe_unwrap()()
    }

    pub unsafe fn set_task_progress(&self, task: u64, text: &std::ffi::CStr, fraction: f32) {
        let text = text.as_ptr();
        ((*self.0).set_task_progress).unsafe_unwrap()(task, text, fraction)
    }
}

impl crate::Api for ProgressReportApi {
    const NAME: *const i8 = TM_PROGRESS_REPORT_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_progress_report_api)
    }
}
unsafe impl Send for ProgressReportApi {}
unsafe impl Sync for ProgressReportApi {}
pub struct RandomApi(pub *const tm_random_api);

impl RandomApi {
    pub unsafe fn next(&self) -> u64 {
        ((*self.0).next).unsafe_unwrap()()
    }

    pub unsafe fn next_n(&self, res: *mut u64, n: u32) {
        ((*self.0).next_n).unsafe_unwrap()(res, n)
    }

    pub unsafe fn seed_new_state(&self, s: *mut u64) {
        ((*self.0).seed_new_state).unsafe_unwrap()(s)
    }
}

impl crate::Api for RandomApi {
    const NAME: *const i8 = TM_RANDOM_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_random_api)
    }
}
unsafe impl Send for RandomApi {}
unsafe impl Sync for RandomApi {}
pub struct RuntimeDataRepositoryApi(pub *const tm_runtime_data_repository_api);

impl RuntimeDataRepositoryApi {
    pub unsafe fn create(
        &self,
        allocator: *mut tm_allocator_i,
        tt: *mut tm_the_truth_o,
        type_: tm_tt_type_t,
        runtime_data_size: u32,
        io_interface: *mut tm_runtime_data_io_i,
    ) -> *mut tm_runtime_data_repository_o {
        ((*self.0).create).unsafe_unwrap()(allocator, tt, type_, runtime_data_size, io_interface)
    }

    pub unsafe fn destroy(
        &self,
        inst: *mut tm_runtime_data_repository_o,
        io_context: *mut ::std::os::raw::c_void,
    ) {
        ((*self.0).destroy).unsafe_unwrap()(inst, io_context)
    }

    pub unsafe fn lookup(
        &self,
        inst: *mut tm_runtime_data_repository_o,
        id: tm_tt_id_t,
        wanted_version: u64,
        io_context: *mut ::std::os::raw::c_void,
    ) -> tm_runtime_data_t {
        ((*self.0).lookup).unsafe_unwrap()(inst, id, wanted_version, io_context)
    }

    pub unsafe fn garbage_collect(
        &self,
        inst: *mut tm_runtime_data_repository_o,
        io_context: *mut ::std::os::raw::c_void,
    ) {
        ((*self.0).garbage_collect).unsafe_unwrap()(inst, io_context)
    }
}

impl crate::Api for RuntimeDataRepositoryApi {
    const NAME: *const i8 = TM_RUNTIME_DATA_REPOSITORY_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_runtime_data_repository_api)
    }
}
unsafe impl Send for RuntimeDataRepositoryApi {}
unsafe impl Sync for RuntimeDataRepositoryApi {}
pub struct SprintfApi(pub *const tm_sprintf_api);

impl SprintfApi {
    pub unsafe fn print_unsafe(
        &self,
        buf: *mut ::std::os::raw::c_char,
        fmt: &std::ffi::CStr,
    ) -> ::std::os::raw::c_int {
        let fmt = fmt.as_ptr();
        ((*self.0).print_unsafe).unsafe_unwrap()(buf, fmt)
    }

    pub unsafe fn print(
        &self,
        buf: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        fmt: &std::ffi::CStr,
    ) -> ::std::os::raw::c_int {
        let fmt = fmt.as_ptr();
        ((*self.0).print).unsafe_unwrap()(buf, count, fmt)
    }

    pub unsafe fn vprint_unsafe(
        &self,
        buf: *mut ::std::os::raw::c_char,
        fmt: &std::ffi::CStr,
        va: va_list,
    ) -> ::std::os::raw::c_int {
        let fmt = fmt.as_ptr();
        ((*self.0).vprint_unsafe).unsafe_unwrap()(buf, fmt, va)
    }

    pub unsafe fn vprint(
        &self,
        buf: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        fmt: &std::ffi::CStr,
        va: va_list,
    ) -> ::std::os::raw::c_int {
        let fmt = fmt.as_ptr();
        ((*self.0).vprint).unsafe_unwrap()(buf, count, fmt, va)
    }

    pub unsafe fn add_printer(&self, name: &std::ffi::CStr, printer: tm_sprintf_printer) {
        let name = name.as_ptr();
        ((*self.0).add_printer).unsafe_unwrap()(name, printer)
    }
}

impl crate::Api for SprintfApi {
    const NAME: *const i8 = TM_SPRINTF_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_sprintf_api)
    }
}
unsafe impl Send for SprintfApi {}
unsafe impl Sync for SprintfApi {}
pub struct StringApi(pub *const tm_string_api);

impl StringApi {
    pub unsafe fn find_unique_name(
        &self,
        taken_names: *mut tm_set_strhash_t,
        ignore_case: bool,
        desired_name: &std::ffi::CStr,
        separator: &std::ffi::CStr,
        ta: *mut tm_temp_allocator_i,
    ) -> *const ::std::os::raw::c_char {
        let desired_name = desired_name.as_ptr();
        let separator = separator.as_ptr();
        ((*self.0).find_unique_name).unsafe_unwrap()(
            taken_names,
            ignore_case,
            desired_name,
            separator,
            ta,
        )
    }
}

impl crate::Api for StringApi {
    const NAME: *const i8 = TM_STRING_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_string_api)
    }
}
unsafe impl Send for StringApi {}
unsafe impl Sync for StringApi {}
pub struct StringRepositoryApi(pub *const tm_string_repository_api);

impl StringRepositoryApi {
    pub unsafe fn create(&self, a: *mut tm_allocator_i) -> *mut tm_string_repository_i {
        ((*self.0).create).unsafe_unwrap()(a)
    }

    pub unsafe fn destroy(&self, i: *mut tm_string_repository_i) {
        ((*self.0).destroy).unsafe_unwrap()(i)
    }
}

impl crate::Api for StringRepositoryApi {
    const NAME: *const i8 = TM_STRING_REPOSITORY_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_string_repository_api)
    }
}
unsafe impl Send for StringRepositoryApi {}
unsafe impl Sync for StringRepositoryApi {}
pub struct TaskSystemApi(pub *const tm_task_system_api);

impl TaskSystemApi {
    pub unsafe fn run_task(
        &self,
        f: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u64)>,
        data: *mut ::std::os::raw::c_void,
        debug_name: &std::ffi::CStr,
    ) -> u64 {
        let debug_name = debug_name.as_ptr();
        ((*self.0).run_task).unsafe_unwrap()(f, data, debug_name)
    }

    pub unsafe fn is_task_done(&self, id: u64) -> bool {
        ((*self.0).is_task_done).unsafe_unwrap()(id)
    }

    pub unsafe fn is_task_done_else_assist(&self, id: u64) -> bool {
        ((*self.0).is_task_done_else_assist).unsafe_unwrap()(id)
    }

    pub unsafe fn cancel_task(&self, id: u64) {
        ((*self.0).cancel_task).unsafe_unwrap()(id)
    }

    pub unsafe fn is_task_canceled(&self, id: u64) -> bool {
        ((*self.0).is_task_canceled).unsafe_unwrap()(id)
    }
}

impl crate::Api for TaskSystemApi {
    const NAME: *const i8 = TM_TASK_SYSTEM_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_task_system_api)
    }
}
unsafe impl Send for TaskSystemApi {}
unsafe impl Sync for TaskSystemApi {}
pub struct TempAllocatorApi(pub *const tm_temp_allocator_api);

impl TempAllocatorApi {
    pub unsafe fn init_1024(
        &self,
        ta: *mut tm_temp_allocator_1024_o,
        backing: *mut tm_allocator_i,
    ) {
        ((*self.0).init_1024).unsafe_unwrap()(ta, backing)
    }

    pub unsafe fn shutdown_1024(&self, ta: *mut tm_temp_allocator_1024_o) {
        ((*self.0).shutdown_1024).unsafe_unwrap()(ta)
    }

    pub unsafe fn create(&self, backing: *mut tm_allocator_i) -> *mut tm_temp_allocator_i {
        ((*self.0).create).unsafe_unwrap()(backing)
    }

    pub unsafe fn destroy(&self, ta: *mut tm_temp_allocator_i) {
        ((*self.0).destroy).unsafe_unwrap()(ta)
    }

    pub unsafe fn allocator(&self, a: *mut tm_allocator_i, ta: *mut tm_temp_allocator_i) {
        ((*self.0).allocator).unsafe_unwrap()(a, ta)
    }

    pub unsafe fn frame_alloc(&self, size: u64) -> *mut ::std::os::raw::c_void {
        ((*self.0).frame_alloc).unsafe_unwrap()(size)
    }

    pub unsafe fn frame_allocator(&self) -> *mut tm_allocator_i {
        ((*self.0).frame_allocator).unsafe_unwrap()()
    }

    pub unsafe fn tick_frame(&self) {
        ((*self.0).tick_frame).unsafe_unwrap()()
    }

    pub unsafe fn printf(
        &self,
        ta: *mut tm_temp_allocator_i,
        format: &std::ffi::CStr,
    ) -> *mut ::std::os::raw::c_char {
        let format = format.as_ptr();
        ((*self.0).printf).unsafe_unwrap()(ta, format)
    }

    pub unsafe fn vprintf(
        &self,
        ta: *mut tm_temp_allocator_i,
        format: &std::ffi::CStr,
        args: va_list,
    ) -> *mut ::std::os::raw::c_char {
        let format = format.as_ptr();
        ((*self.0).vprintf).unsafe_unwrap()(ta, format, args)
    }

    pub unsafe fn frame_printf(&self, format: &std::ffi::CStr) -> *mut ::std::os::raw::c_char {
        let format = format.as_ptr();
        ((*self.0).frame_printf).unsafe_unwrap()(format)
    }

    pub unsafe fn frame_vprintf(
        &self,
        format: &std::ffi::CStr,
        args: va_list,
    ) -> *mut ::std::os::raw::c_char {
        let format = format.as_ptr();
        ((*self.0).frame_vprintf).unsafe_unwrap()(format, args)
    }
}

impl crate::Api for TempAllocatorApi {
    const NAME: *const i8 = TM_TEMP_ALLOCATOR_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_temp_allocator_api)
    }
}
unsafe impl Send for TempAllocatorApi {}
unsafe impl Sync for TempAllocatorApi {}
pub struct TheTruthApi(pub *const tm_the_truth_api);

impl TheTruthApi {
    pub unsafe fn allocator(&self, tt: *mut tm_the_truth_o) -> *mut tm_allocator_i {
        ((*self.0).allocator).unsafe_unwrap()(tt)
    }

    pub unsafe fn buffers(&self, tt: *mut tm_the_truth_o) -> *mut tm_buffers_i {
        ((*self.0).buffers).unsafe_unwrap()(tt)
    }

    pub unsafe fn streamable_buffers(
        &self,
        tt: *mut tm_the_truth_o,
    ) -> *mut tm_streamable_buffers_i {
        ((*self.0).streamable_buffers).unsafe_unwrap()(tt)
    }

    pub unsafe fn create_object_type(
        &self,
        tt: *mut tm_the_truth_o,
        name: &std::ffi::CStr,
        properties: *const tm_the_truth_property_definition_t,
        num_properties: u32,
    ) -> tm_tt_type_t {
        let name = name.as_ptr();
        ((*self.0).create_object_type).unsafe_unwrap()(tt, name, properties, num_properties)
    }

    pub unsafe fn set_default_object(
        &self,
        tt: *mut tm_the_truth_o,
        object_type: tm_tt_type_t,
        object: tm_tt_id_t,
    ) {
        ((*self.0).set_default_object).unsafe_unwrap()(tt, object_type, object)
    }

    pub unsafe fn set_default_object_to_create_subobjects(
        &self,
        tt: *mut tm_the_truth_o,
        object_type: tm_tt_type_t,
    ) {
        ((*self.0).set_default_object_to_create_subobjects).unsafe_unwrap()(tt, object_type)
    }

    pub unsafe fn default_object(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
    ) -> tm_tt_id_t {
        ((*self.0).default_object).unsafe_unwrap()(tt, object_type)
    }

    pub unsafe fn is_default(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> bool {
        ((*self.0).is_default).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn set_aspect(
        &self,
        tt: *mut tm_the_truth_o,
        object_type: tm_tt_type_t,
        aspect: tm_strhash_t,
        data: *const ::std::os::raw::c_void,
    ) {
        ((*self.0).set_aspect).unsafe_unwrap()(tt, object_type, aspect, data)
    }

    pub unsafe fn set_default_aspect(
        &self,
        tt: *mut tm_the_truth_o,
        aspect: tm_strhash_t,
        data: *const ::std::os::raw::c_void,
    ) {
        ((*self.0).set_default_aspect).unsafe_unwrap()(tt, aspect, data)
    }

    pub unsafe fn set_property_aspect(
        &self,
        tt: *mut tm_the_truth_o,
        object_type: tm_tt_type_t,
        property: u32,
        aspect: tm_strhash_t,
        data: *const ::std::os::raw::c_void,
    ) {
        ((*self.0).set_property_aspect).unsafe_unwrap()(tt, object_type, property, aspect, data)
    }

    pub unsafe fn reload_aspects(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).reload_aspects).unsafe_unwrap()(tt)
    }

    pub unsafe fn object_type_from_name_hash(
        &self,
        tt: *const tm_the_truth_o,
        name_hash: tm_strhash_t,
    ) -> tm_tt_type_t {
        ((*self.0).object_type_from_name_hash).unsafe_unwrap()(tt, name_hash)
    }

    pub unsafe fn optional_object_type_from_name_hash(
        &self,
        tt: *const tm_the_truth_o,
        name_hash: tm_strhash_t,
    ) -> tm_tt_type_t {
        ((*self.0).optional_object_type_from_name_hash).unsafe_unwrap()(tt, name_hash)
    }

    pub unsafe fn num_types(&self, tt: *const tm_the_truth_o) -> u32 {
        ((*self.0).num_types).unsafe_unwrap()(tt)
    }

    pub unsafe fn type_name(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).type_name).unsafe_unwrap()(tt, object_type)
    }

    pub unsafe fn type_name_hash(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
    ) -> tm_strhash_t {
        ((*self.0).type_name_hash).unsafe_unwrap()(tt, object_type)
    }

    pub unsafe fn num_properties(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
    ) -> u32 {
        ((*self.0).num_properties).unsafe_unwrap()(tt, object_type)
    }

    pub unsafe fn properties(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
    ) -> *const tm_the_truth_property_definition_t {
        ((*self.0).properties).unsafe_unwrap()(tt, object_type)
    }

    pub unsafe fn find_property(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
        name_hash: tm_strhash_t,
        type_: u32,
        res: *mut u32,
    ) -> bool {
        ((*self.0).find_property).unsafe_unwrap()(tt, object_type, name_hash, type_, res)
    }

    pub unsafe fn property_index(
        &self,
        tt: *const tm_the_truth_o,
        type_: tm_tt_type_t,
        name_hash: tm_strhash_t,
    ) -> u32 {
        ((*self.0).property_index).unsafe_unwrap()(tt, type_, name_hash)
    }

    pub unsafe fn has_property(
        &self,
        tt: *const tm_the_truth_o,
        type_: tm_tt_type_t,
        name_hash: tm_strhash_t,
    ) -> u32 {
        ((*self.0).has_property).unsafe_unwrap()(tt, type_, name_hash)
    }

    pub unsafe fn get_aspect(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
        aspect: tm_strhash_t,
    ) -> *mut ::std::os::raw::c_void {
        ((*self.0).get_aspect).unsafe_unwrap()(tt, object_type, aspect)
    }

    pub unsafe fn get_types_with_aspect(
        &self,
        tt: *const tm_the_truth_o,
        aspect: tm_strhash_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_the_truth_get_types_with_aspect_t {
        ((*self.0).get_types_with_aspect).unsafe_unwrap()(tt, aspect, ta)
    }

    pub unsafe fn get_aspects(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
    ) -> *const tm_the_truth_get_aspects_t {
        ((*self.0).get_aspects).unsafe_unwrap()(tt, object_type)
    }

    pub unsafe fn get_property_aspect(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
        property: u32,
        aspect: tm_strhash_t,
    ) -> *mut ::std::os::raw::c_void {
        ((*self.0).get_property_aspect).unsafe_unwrap()(tt, object_type, property, aspect)
    }

    pub unsafe fn all_objects_of_type(
        &self,
        tt: *const tm_the_truth_o,
        object_type: tm_tt_type_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_tt_id_t {
        ((*self.0).all_objects_of_type).unsafe_unwrap()(tt, object_type, ta)
    }

    pub unsafe fn create_undo_scope(
        &self,
        tt: *mut tm_the_truth_o,
        name: &std::ffi::CStr,
    ) -> tm_tt_undo_scope_t {
        let name = name.as_ptr();
        ((*self.0).create_undo_scope).unsafe_unwrap()(tt, name)
    }

    pub unsafe fn create_thread_safe_undo_scope(
        &self,
        tt: *mut tm_the_truth_o,
        name: &std::ffi::CStr,
    ) -> tm_tt_undo_scope_t {
        let name = name.as_ptr();
        ((*self.0).create_thread_safe_undo_scope).unsafe_unwrap()(tt, name)
    }

    pub unsafe fn undo_scope_name(
        &self,
        tt: *mut tm_the_truth_o,
        scope: tm_tt_undo_scope_t,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).undo_scope_name).unsafe_unwrap()(tt, scope)
    }

    pub unsafe fn undo_scope_objects(
        &self,
        tt: *mut tm_the_truth_o,
        scope: tm_tt_undo_scope_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_tt_id_t {
        ((*self.0).undo_scope_objects).unsafe_unwrap()(tt, scope, ta)
    }

    pub unsafe fn undo_scope_actions(
        &self,
        tt: *mut tm_the_truth_o,
        scope: tm_tt_undo_scope_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_tt_undo_action_t {
        ((*self.0).undo_scope_actions).unsafe_unwrap()(tt, scope, ta)
    }

    pub unsafe fn undo(&self, tt: *mut tm_the_truth_o, scope: tm_tt_undo_scope_t) {
        ((*self.0).undo).unsafe_unwrap()(tt, scope)
    }

    pub unsafe fn redo(&self, tt: *mut tm_the_truth_o, scope: tm_tt_undo_scope_t) {
        ((*self.0).redo).unsafe_unwrap()(tt, scope)
    }

    pub unsafe fn create_object_of_type(
        &self,
        tt: *mut tm_the_truth_o,
        type_: tm_tt_type_t,
        undo_scope: tm_tt_undo_scope_t,
    ) -> tm_tt_id_t {
        ((*self.0).create_object_of_type).unsafe_unwrap()(tt, type_, undo_scope)
    }

    pub unsafe fn create_object_of_hash(
        &self,
        tt: *mut tm_the_truth_o,
        type_name_hash: tm_strhash_t,
        undo_scope: tm_tt_undo_scope_t,
    ) -> tm_tt_id_t {
        ((*self.0).create_object_of_hash).unsafe_unwrap()(tt, type_name_hash, undo_scope)
    }

    pub unsafe fn create_object_from_prototype(
        &self,
        tt: *mut tm_the_truth_o,
        prototype: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) -> tm_tt_id_t {
        ((*self.0).create_object_from_prototype).unsafe_unwrap()(tt, prototype, undo_scope)
    }

    pub unsafe fn clone_object(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) -> tm_tt_id_t {
        ((*self.0).clone_object).unsafe_unwrap()(tt, object, undo_scope)
    }

    pub unsafe fn instantiate_subobject(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        undo_scope: tm_tt_undo_scope_t,
    ) -> tm_tt_id_t {
        ((*self.0).instantiate_subobject).unsafe_unwrap()(tt, obj, property, undo_scope)
    }

    pub unsafe fn remove_instantiated_subobject(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).remove_instantiated_subobject).unsafe_unwrap()(tt, obj, property, undo_scope)
    }

    pub unsafe fn instantiate_subobject_from_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        subobject: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) -> tm_tt_id_t {
        ((*self.0).instantiate_subobject_from_set).unsafe_unwrap()(
            tt, obj, property, subobject, undo_scope,
        )
    }

    pub unsafe fn remove_instantiated_subobject_from_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        subobject: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).remove_instantiated_subobject_from_set).unsafe_unwrap()(
            tt, obj, property, subobject, undo_scope,
        )
    }

    pub unsafe fn add_instantiated_subobject_back_to_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        subobject: tm_tt_id_t,
    ) {
        ((*self.0).add_instantiated_subobject_back_to_set).unsafe_unwrap()(
            tt, obj, property, subobject,
        )
    }

    pub unsafe fn id(&self, obj: *const tm_the_truth_object_o) -> tm_tt_id_t {
        ((*self.0).id).unsafe_unwrap()(obj)
    }

    pub unsafe fn destroy_object(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).destroy_object).unsafe_unwrap()(tt, object, undo_scope)
    }

    pub unsafe fn destroy_objects(
        &self,
        tt: *mut tm_the_truth_o,
        object: *const tm_tt_id_t,
        n: u32,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).destroy_objects).unsafe_unwrap()(tt, object, n, undo_scope)
    }

    pub unsafe fn garbage_collect(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).garbage_collect).unsafe_unwrap()(tt)
    }

    pub unsafe fn is_alive(&self, tt: *const tm_the_truth_o, object: tm_tt_id_t) -> bool {
        ((*self.0).is_alive).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn interop_ensure_compatibility(&self, ctx: *mut tm_the_truth_interop_context_t) {
        ((*self.0).interop_ensure_compatibility).unsafe_unwrap()(ctx)
    }

    pub unsafe fn interop_clone_object(
        &self,
        ctx: *mut tm_the_truth_interop_context_t,
        object: tm_tt_id_t,
    ) -> tm_tt_id_t {
        ((*self.0).interop_clone_object).unsafe_unwrap()(ctx, object)
    }

    pub unsafe fn deep_clone_assets(
        &self,
        to_tt: *mut tm_the_truth_o,
        from_tt: *const tm_the_truth_o,
        assets: *const tm_tt_id_t,
        n: u32,
        undo_scope: tm_tt_undo_scope_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_tt_id_t {
        ((*self.0).deep_clone_assets).unsafe_unwrap()(to_tt, from_tt, assets, n, undo_scope, ta)
    }

    pub unsafe fn uuid(&self, tt: *const tm_the_truth_o, object: tm_tt_id_t) -> tm_uuid_t {
        ((*self.0).uuid).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn read(
        &self,
        tt: *const tm_the_truth_o,
        object: tm_tt_id_t,
    ) -> *const tm_the_truth_object_o {
        ((*self.0).read).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn get_bool(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> bool {
        ((*self.0).get_bool).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_uint32_t(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> u32 {
        ((*self.0).get_uint32_t).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_uint64_t(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> u64 {
        ((*self.0).get_uint64_t).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_float(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> f32 {
        ((*self.0).get_float).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_double(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> f64 {
        ((*self.0).get_double).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_string(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).get_string).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_string_hash(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_strhash_t {
        ((*self.0).get_string_hash).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_str(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_str_t {
        ((*self.0).get_str).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_buffer(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_tt_buffer_t {
        ((*self.0).get_buffer).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_reference(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_tt_id_t {
        ((*self.0).get_reference).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_subobject(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_tt_id_t {
        ((*self.0).get_subobject).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_property_value(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> tm_tt_prop_value_t {
        ((*self.0).get_property_value).unsafe_unwrap()(tt, obj, property, ta)
    }

    pub unsafe fn property_value_equal(
        &self,
        a: tm_tt_prop_value_t,
        b: tm_tt_prop_value_t,
    ) -> bool {
        ((*self.0).property_value_equal).unsafe_unwrap()(a, b)
    }

    pub unsafe fn get_reference_set(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *const tm_tt_id_t {
        ((*self.0).get_reference_set).unsafe_unwrap()(tt, obj, property, ta)
    }

    pub unsafe fn get_subobject_set(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *const tm_tt_id_t {
        ((*self.0).get_subobject_set).unsafe_unwrap()(tt, obj, property, ta)
    }

    pub unsafe fn get_reference_set_size(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> u64 {
        ((*self.0).get_reference_set_size).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_subobject_set_size(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> u64 {
        ((*self.0).get_subobject_set_size).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_subobject_set_locally_removed(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *const tm_tt_id_t {
        ((*self.0).get_subobject_set_locally_removed).unsafe_unwrap()(tt, obj, property, ta)
    }

    pub unsafe fn find_subobject_of_type(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
        type_: tm_tt_type_t,
    ) -> tm_tt_id_t {
        ((*self.0).find_subobject_of_type).unsafe_unwrap()(tt, obj, property, type_)
    }

    pub unsafe fn is_subobject_of(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
        subobject: tm_tt_id_t,
    ) -> bool {
        ((*self.0).is_subobject_of).unsafe_unwrap()(tt, obj, property, subobject)
    }

    pub unsafe fn is_in_reference_set(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
        object: tm_tt_id_t,
    ) -> bool {
        ((*self.0).is_in_reference_set).unsafe_unwrap()(tt, obj, property, object)
    }

    pub unsafe fn property_index_of_subobject(
        &self,
        tt: *const tm_the_truth_o,
        object: tm_tt_id_t,
        subobject: tm_tt_id_t,
    ) -> u32 {
        ((*self.0).property_index_of_subobject).unsafe_unwrap()(tt, object, subobject)
    }

    pub unsafe fn write(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
    ) -> *mut tm_the_truth_object_o {
        ((*self.0).write).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn commit(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).commit).unsafe_unwrap()(tt, obj, undo_scope)
    }

    pub unsafe fn commit_range(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut *mut tm_the_truth_object_o,
        n: u32,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).commit_range).unsafe_unwrap()(tt, obj, n, undo_scope)
    }

    pub unsafe fn retarget_write(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        object: tm_tt_id_t,
    ) {
        ((*self.0).retarget_write).unsafe_unwrap()(tt, obj, object)
    }

    pub unsafe fn try_write(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        original: *mut *const tm_the_truth_object_o,
    ) -> *mut tm_the_truth_object_o {
        ((*self.0).try_write).unsafe_unwrap()(tt, object, original)
    }

    pub unsafe fn try_commit(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        original: *const tm_the_truth_object_o,
        undo_scope: tm_tt_undo_scope_t,
    ) -> bool {
        ((*self.0).try_commit).unsafe_unwrap()(tt, obj, original, undo_scope)
    }

    pub unsafe fn set_bool(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: bool,
    ) {
        ((*self.0).set_bool).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_uint32_t(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: u32,
    ) {
        ((*self.0).set_uint32_t).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_uint64_t(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: u64,
    ) {
        ((*self.0).set_uint64_t).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_float(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: f32,
    ) {
        ((*self.0).set_float).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_double(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: f64,
    ) {
        ((*self.0).set_double).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_string(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: &std::ffi::CStr,
    ) {
        let value = value.as_ptr();
        ((*self.0).set_string).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_str(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: tm_str_t,
    ) {
        ((*self.0).set_str).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_buffer(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: u32,
    ) {
        ((*self.0).set_buffer).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_buffer_content(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        p: *mut ::std::os::raw::c_void,
        size: u64,
    ) {
        ((*self.0).set_buffer_content).unsafe_unwrap()(tt, obj, property, p, size)
    }

    pub unsafe fn set_reference(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: tm_tt_id_t,
    ) {
        ((*self.0).set_reference).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_subobject(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: *mut tm_the_truth_object_o,
    ) {
        ((*self.0).set_subobject).unsafe_unwrap()(tt, obj, property, value)
    }

    pub unsafe fn set_subobject_id(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_subobject_id).unsafe_unwrap()(tt, obj, property, value, undo_scope)
    }

    pub unsafe fn set_property_value(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        value: tm_tt_prop_value_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_property_value).unsafe_unwrap()(tt, obj, property, value, undo_scope)
    }

    pub unsafe fn clear(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
    ) {
        ((*self.0).clear).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn clear_object(&self, tt: *mut tm_the_truth_o, obj: *mut tm_the_truth_object_o) {
        ((*self.0).clear_object).unsafe_unwrap()(tt, obj)
    }

    pub unsafe fn propagate_property(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        property: u32,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).propagate_property).unsafe_unwrap()(tt, object, property, undo_scope)
    }

    pub unsafe fn propagate_property_except(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        property: u32,
        skip: *const tm_tt_id_t,
        num_skip: u32,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).propagate_property_except).unsafe_unwrap()(
            tt, object, property, skip, num_skip, undo_scope,
        )
    }

    pub unsafe fn propagate_property_subobject(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        property: u32,
        subobject: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).propagate_property_subobject).unsafe_unwrap()(
            tt, object, property, subobject, undo_scope,
        )
    }

    pub unsafe fn propagate_object(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).propagate_object).unsafe_unwrap()(tt, object, undo_scope)
    }

    pub unsafe fn propagate_object_except(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        skip: *const tm_tt_id_t,
        num_skip: u32,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).propagate_object_except).unsafe_unwrap()(tt, object, skip, num_skip, undo_scope)
    }

    pub unsafe fn add_to_reference_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        items: *const tm_tt_id_t,
        count: u32,
    ) {
        ((*self.0).add_to_reference_set).unsafe_unwrap()(tt, obj, property, items, count)
    }

    pub unsafe fn remove_from_reference_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        items: *const tm_tt_id_t,
        count: u32,
    ) {
        ((*self.0).remove_from_reference_set).unsafe_unwrap()(tt, obj, property, items, count)
    }

    pub unsafe fn clear_reference_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
    ) {
        ((*self.0).clear_reference_set).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn remove_from_prototype_reference_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        items: *const tm_tt_id_t,
        count: u32,
    ) {
        ((*self.0).remove_from_prototype_reference_set).unsafe_unwrap()(
            tt, obj, property, items, count,
        )
    }

    pub unsafe fn cancel_remove_from_prototype_reference_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        items: *const tm_tt_id_t,
        count: u32,
    ) {
        ((*self.0).cancel_remove_from_prototype_reference_set).unsafe_unwrap()(
            tt, obj, property, items, count,
        )
    }

    pub unsafe fn add_to_subobject_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        items: *mut *mut tm_the_truth_object_o,
        count: u32,
    ) {
        ((*self.0).add_to_subobject_set).unsafe_unwrap()(tt, obj, property, items, count)
    }

    pub unsafe fn remove_from_subobject_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        items: *const tm_tt_id_t,
        count: u32,
    ) {
        ((*self.0).remove_from_subobject_set).unsafe_unwrap()(tt, obj, property, items, count)
    }

    pub unsafe fn clear_subobject_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
    ) {
        ((*self.0).clear_subobject_set).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn remove_from_prototype_subobject_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        items: *const tm_tt_id_t,
        count: u32,
    ) {
        ((*self.0).remove_from_prototype_subobject_set).unsafe_unwrap()(
            tt, obj, property, items, count,
        )
    }

    pub unsafe fn cancel_remove_from_prototype_subobject_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        items: *const tm_tt_id_t,
        count: u32,
    ) {
        ((*self.0).cancel_remove_from_prototype_subobject_set).unsafe_unwrap()(
            tt, obj, property, items, count,
        )
    }

    pub unsafe fn prototype(&self, tt: *const tm_the_truth_o, object: tm_tt_id_t) -> tm_tt_id_t {
        ((*self.0).prototype).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn owner(&self, tt: *const tm_the_truth_o, object: tm_tt_id_t) -> tm_tt_id_t {
        ((*self.0).owner).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn is_currently_owner_of(
        &self,
        tt: *const tm_the_truth_o,
        object: tm_tt_id_t,
        subobject: tm_tt_id_t,
    ) -> bool {
        ((*self.0).is_currently_owner_of).unsafe_unwrap()(tt, object, subobject)
    }

    pub unsafe fn is_overridden(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> bool {
        ((*self.0).is_overridden).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn has_data(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> bool {
        ((*self.0).has_data).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn prototype_relation(
        &self,
        tt: *const tm_the_truth_o,
        parent: tm_tt_id_t,
        property: u32,
        object: tm_tt_id_t,
    ) -> tm_the_truth_prototype_relation {
        ((*self.0).prototype_relation).unsafe_unwrap()(tt, parent, property, object)
    }

    pub unsafe fn version(&self, tt: *const tm_the_truth_o, object: tm_tt_id_t) -> u32 {
        ((*self.0).version).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn changed_objects(
        &self,
        tt: *const tm_the_truth_o,
        type_: tm_tt_type_t,
        since_version: u64,
        ta: *mut tm_temp_allocator_i,
    ) -> tm_the_truth_changed_objects_t {
        ((*self.0).changed_objects).unsafe_unwrap()(tt, type_, since_version, ta)
    }

    pub unsafe fn request_changelog(&self, tt: *mut tm_the_truth_o) -> u64 {
        ((*self.0).request_changelog).unsafe_unwrap()(tt)
    }

    pub unsafe fn relinquish_changelog(&self, tt: *mut tm_the_truth_o, h: u64) {
        ((*self.0).relinquish_changelog).unsafe_unwrap()(tt, h)
    }

    pub unsafe fn disable_changelog_start_scope(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).disable_changelog_start_scope).unsafe_unwrap()(tt)
    }

    pub unsafe fn disable_changelog_end_scope(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).disable_changelog_end_scope).unsafe_unwrap()(tt)
    }

    pub unsafe fn changelog_size(&self, tt: *mut tm_the_truth_o) -> u64 {
        ((*self.0).changelog_size).unsafe_unwrap()(tt)
    }

    pub unsafe fn serialize(
        &self,
        tt: *mut tm_the_truth_o,
        o: tm_tt_id_t,
        carray: *mut *mut ::std::os::raw::c_char,
        a: *mut tm_allocator_i,
        opt: *const tm_tt_serialize_options_t,
    ) {
        ((*self.0).serialize).unsafe_unwrap()(tt, o, carray, a, opt)
    }

    pub unsafe fn deserialize(
        &self,
        tt: *mut tm_the_truth_o,
        buffer: *mut *const ::std::os::raw::c_char,
        opt: *const tm_tt_deserialize_options_t,
    ) -> tm_tt_id_t {
        ((*self.0).deserialize).unsafe_unwrap()(tt, buffer, opt)
    }

    pub unsafe fn buffer_hashes(
        &self,
        buffer: *mut *const ::std::os::raw::c_char,
        count: *mut u64,
    ) -> *const u64 {
        ((*self.0).buffer_hashes).unsafe_unwrap()(buffer, count)
    }

    pub unsafe fn deserialize_from_file(
        &self,
        tt: *mut tm_the_truth_o,
        file: &std::ffi::CStr,
    ) -> tm_tt_id_t {
        let file = file.as_ptr();
        ((*self.0).deserialize_from_file).unsafe_unwrap()(tt, file)
    }

    pub unsafe fn migration_ids(
        &self,
        tt: *const tm_the_truth_o,
        n: *mut u32,
    ) -> *mut tm_strhash_t {
        ((*self.0).migration_ids).unsafe_unwrap()(tt, n)
    }

    pub unsafe fn serialize_changes_header(
        &self,
        tt: *mut tm_the_truth_o,
        carray: *mut *mut ::std::os::raw::c_char,
        a: *mut tm_allocator_i,
    ) {
        ((*self.0).serialize_changes_header).unsafe_unwrap()(tt, carray, a)
    }

    pub unsafe fn serialize_changes(
        &self,
        tt: *mut tm_the_truth_o,
        begin: u64,
        end: u64,
        carray: *mut *mut ::std::os::raw::c_char,
        a: *mut tm_allocator_i,
        opt: *const tm_tt_serialize_changes_options_t,
    ) {
        ((*self.0).serialize_changes).unsafe_unwrap()(tt, begin, end, carray, a, opt)
    }

    pub unsafe fn deserialize_changes(
        &self,
        tt: *mut tm_the_truth_o,
        buffer: *mut *const ::std::os::raw::c_char,
        opt: *const tm_tt_deserialize_changes_options_t,
    ) {
        ((*self.0).deserialize_changes).unsafe_unwrap()(tt, buffer, opt)
    }

    pub unsafe fn serialize_patch(
        &self,
        from_tt: *mut tm_the_truth_o,
        from_o: tm_tt_id_t,
        to_tt: *mut tm_the_truth_o,
        to_o: tm_tt_id_t,
        carray: *mut *mut ::std::os::raw::c_char,
        a: *mut tm_allocator_i,
    ) {
        ((*self.0).serialize_patch).unsafe_unwrap()(from_tt, from_o, to_tt, to_o, carray, a)
    }

    pub unsafe fn deserialize_patch(
        &self,
        tt: *mut tm_the_truth_o,
        buffer: *mut *const ::std::os::raw::c_char,
    ) {
        ((*self.0).deserialize_patch).unsafe_unwrap()(tt, buffer)
    }

    pub unsafe fn deserialize_patch_from_file(
        &self,
        tt: *mut tm_the_truth_o,
        file: &std::ffi::CStr,
    ) {
        let file = file.as_ptr();
        ((*self.0).deserialize_patch_from_file).unsafe_unwrap()(tt, file)
    }

    pub unsafe fn serialize_type(
        &self,
        tt: *mut tm_the_truth_o,
        type_: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut ::std::os::raw::c_char {
        ((*self.0).serialize_type).unsafe_unwrap()(tt, type_, ta)
    }

    pub unsafe fn deserialize_type(
        &self,
        tt: *mut tm_the_truth_o,
        buf: *mut *const ::std::os::raw::c_char,
        type_info: *mut tm_the_truth_serialized_type_info_t,
    ) {
        ((*self.0).deserialize_type).unsafe_unwrap()(tt, buf, type_info)
    }

    pub unsafe fn memory_use(
        &self,
        tt: *mut tm_the_truth_o,
        id: tm_tt_id_t,
        buffers: *mut tm_set_t,
    ) -> tm_tt_memory_use_t {
        ((*self.0).memory_use).unsafe_unwrap()(tt, id, buffers)
    }

    pub unsafe fn add_properties(
        &self,
        tt: *mut tm_the_truth_o,
        type_: tm_tt_type_t,
        properties: *const tm_the_truth_property_definition_t,
        num_properties: u32,
    ) {
        ((*self.0).add_properties).unsafe_unwrap()(tt, type_, properties, num_properties)
    }

    pub unsafe fn resolve_or_create_placeholder(
        &self,
        tt: *mut tm_the_truth_o,
        uuid: tm_uuid_t,
        type_: tm_tt_type_t,
        default_initialize: bool,
    ) -> tm_tt_id_t {
        ((*self.0).resolve_or_create_placeholder).unsafe_unwrap()(
            tt,
            uuid,
            type_,
            default_initialize,
        )
    }

    pub unsafe fn resolve_or_fail(
        &self,
        tt: *mut tm_the_truth_o,
        uuid: tm_uuid_t,
        type_: tm_tt_type_t,
    ) -> tm_tt_id_t {
        ((*self.0).resolve_or_fail).unsafe_unwrap()(tt, uuid, type_)
    }

    pub unsafe fn set_uuid(&self, tt: *mut tm_the_truth_o, id: tm_tt_id_t, uuid: tm_uuid_t) {
        ((*self.0).set_uuid).unsafe_unwrap()(tt, id, uuid)
    }

    pub unsafe fn set_prototype(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        id: tm_tt_id_t,
    ) {
        ((*self.0).set_prototype).unsafe_unwrap()(tt, obj, id)
    }

    pub unsafe fn detach_from_prototype(
        &self,
        tt: *mut tm_the_truth_o,
        id: tm_tt_id_t,
        lookup: *mut tm_hash_id_to_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).detach_from_prototype).unsafe_unwrap()(tt, id, lookup, undo_scope)
    }

    pub unsafe fn detach_all_instances(
        &self,
        tt: *mut tm_the_truth_o,
        id: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).detach_all_instances).unsafe_unwrap()(tt, id, undo_scope)
    }

    pub unsafe fn get_local_reference_set(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_the_truth_local_set_t {
        ((*self.0).get_local_reference_set).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn get_local_subobject_set(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_the_truth_local_set_t {
        ((*self.0).get_local_subobject_set).unsafe_unwrap()(tt, obj, property)
    }

    pub unsafe fn set_local_reference_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        set: tm_the_truth_local_set_t,
    ) {
        ((*self.0).set_local_reference_set).unsafe_unwrap()(tt, obj, property, set)
    }

    pub unsafe fn set_local_subobject_set(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        property: u32,
        set: tm_the_truth_set_local_subobject_set_t,
    ) {
        ((*self.0).set_local_subobject_set).unsafe_unwrap()(tt, obj, property, set)
    }

    pub unsafe fn string_repository(&self, tt: *mut tm_the_truth_o) -> *mut tm_string_repository_i {
        ((*self.0).string_repository).unsafe_unwrap()(tt)
    }

    pub unsafe fn set_migration_ids(
        &self,
        tt: *mut tm_the_truth_o,
        ids: *mut tm_strhash_t,
        n: u32,
    ) {
        ((*self.0).set_migration_ids).unsafe_unwrap()(tt, ids, n)
    }

    pub unsafe fn set_properties_to_default(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        mask: u64,
    ) {
        ((*self.0).set_properties_to_default).unsafe_unwrap()(tt, obj, mask)
    }

    pub unsafe fn instantiate_subobjects_recursively(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).instantiate_subobjects_recursively).unsafe_unwrap()(tt, object, undo_scope)
    }

    pub unsafe fn quick_set_properties(
        &self,
        tt: *mut tm_the_truth_o,
        undo_scope: tm_tt_undo_scope_t,
        id: tm_tt_id_t,
    ) {
        ((*self.0).quick_set_properties).unsafe_unwrap()(tt, undo_scope, id)
    }

    pub unsafe fn quick_create_object(
        &self,
        tt: *mut tm_the_truth_o,
        undo_scope: tm_tt_undo_scope_t,
        type_hash: tm_strhash_t,
    ) -> tm_tt_id_t {
        ((*self.0).quick_create_object).unsafe_unwrap()(tt, undo_scope, type_hash)
    }

    pub unsafe fn quick_get_property(
        &self,
        tt: *const tm_the_truth_o,
        id: tm_tt_id_t,
        prop_1: u32,
    ) -> tm_tt_prop_value_t {
        ((*self.0).quick_get_property).unsafe_unwrap()(tt, id, prop_1)
    }

    pub unsafe fn copy_properties_by_name(
        &self,
        t: *mut tm_the_truth_o,
        to: tm_tt_id_t,
        from: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).copy_properties_by_name).unsafe_unwrap()(t, to, from, undo_scope)
    }

    pub unsafe fn debug_inspect(
        &self,
        tt: *const tm_the_truth_o,
        object: tm_tt_id_t,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).debug_inspect).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn create(
        &self,
        a: *mut tm_allocator_i,
        types: tm_the_truth_create_types,
    ) -> *mut tm_the_truth_o {
        ((*self.0).create).unsafe_unwrap()(a, types)
    }

    pub unsafe fn destroy(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).destroy).unsafe_unwrap()(tt)
    }
}

impl crate::Api for TheTruthApi {
    const NAME: *const i8 = TM_THE_TRUTH_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_the_truth_api)
    }
}
unsafe impl Send for TheTruthApi {}
unsafe impl Sync for TheTruthApi {}
pub struct TheTruthAssetsApi(pub *const tm_the_truth_assets_api);

impl TheTruthAssetsApi {
    pub unsafe fn get_asset_path(
        &self,
        tt: *const tm_the_truth_o,
        asset: tm_tt_id_t,
        path: *mut ::std::os::raw::c_char,
        n: u32,
    ) -> u32 {
        ((*self.0).get_asset_path).unsafe_unwrap()(tt, asset, path, n)
    }

    pub unsafe fn get_directory_path(
        &self,
        tt: *const tm_the_truth_o,
        directory: tm_tt_id_t,
        path: *mut ::std::os::raw::c_char,
        n: u32,
    ) -> u32 {
        ((*self.0).get_directory_path).unsafe_unwrap()(tt, directory, path, n)
    }

    pub unsafe fn get_asset_path_with_extension(
        &self,
        tt: *const tm_the_truth_o,
        asset: tm_tt_id_t,
        path: *mut ::std::os::raw::c_char,
        n: u32,
    ) -> u32 {
        ((*self.0).get_asset_path_with_extension).unsafe_unwrap()(tt, asset, path, n)
    }

    pub unsafe fn asset_from_path(
        &self,
        tt: *const tm_the_truth_o,
        asset_root: tm_tt_id_t,
        path: &std::ffi::CStr,
    ) -> tm_tt_id_t {
        let path = path.as_ptr();
        ((*self.0).asset_from_path).unsafe_unwrap()(tt, asset_root, path)
    }

    pub unsafe fn asset_from_path_with_type(
        &self,
        tt: *const tm_the_truth_o,
        asset_root: tm_tt_id_t,
        path: &std::ffi::CStr,
        type_: tm_tt_type_t,
    ) -> tm_tt_id_t {
        let path = path.as_ptr();
        ((*self.0).asset_from_path_with_type).unsafe_unwrap()(tt, asset_root, path, type_)
    }

    pub unsafe fn asset_object_from_path(
        &self,
        tt: *const tm_the_truth_o,
        asset_root: tm_tt_id_t,
        path: &std::ffi::CStr,
    ) -> tm_tt_id_t {
        let path = path.as_ptr();
        ((*self.0).asset_object_from_path).unsafe_unwrap()(tt, asset_root, path)
    }

    pub unsafe fn asset_object_from_path_with_type(
        &self,
        tt: *const tm_the_truth_o,
        asset_root: tm_tt_id_t,
        path: &std::ffi::CStr,
        type_: tm_tt_type_t,
    ) -> tm_tt_id_t {
        let path = path.as_ptr();
        ((*self.0).asset_object_from_path_with_type).unsafe_unwrap()(tt, asset_root, path, type_)
    }

    pub unsafe fn directory_from_path(
        &self,
        tt: *const tm_the_truth_o,
        asset_root: tm_tt_id_t,
        path: &std::ffi::CStr,
    ) -> tm_tt_id_t {
        let path = path.as_ptr();
        ((*self.0).directory_from_path).unsafe_unwrap()(tt, asset_root, path)
    }

    pub unsafe fn find_subdirectory_by_name(
        &self,
        tt: *const tm_the_truth_o,
        asset_root: tm_tt_id_t,
        parent_dir: tm_tt_id_t,
        subdir_name: &std::ffi::CStr,
    ) -> tm_tt_id_t {
        let subdir_name = subdir_name.as_ptr();
        ((*self.0).find_subdirectory_by_name).unsafe_unwrap()(
            tt,
            asset_root,
            parent_dir,
            subdir_name,
        )
    }

    pub unsafe fn unique_asset_name(
        &self,
        tt: *mut tm_the_truth_o,
        asset_root: tm_tt_id_t,
        asset_r: *const tm_the_truth_object_o,
        desired_name: &std::ffi::CStr,
    ) -> *const ::std::os::raw::c_char {
        let desired_name = desired_name.as_ptr();
        ((*self.0).unique_asset_name).unsafe_unwrap()(tt, asset_root, asset_r, desired_name)
    }

    pub unsafe fn unique_directory_name(
        &self,
        tt: *mut tm_the_truth_o,
        asset_root: tm_tt_id_t,
        directory_r: *const tm_the_truth_object_o,
        desired_name: &std::ffi::CStr,
    ) -> *const ::std::os::raw::c_char {
        let desired_name = desired_name.as_ptr();
        ((*self.0).unique_directory_name).unsafe_unwrap()(tt, asset_root, directory_r, desired_name)
    }

    pub unsafe fn object_asset_name(
        &self,
        tt: *mut tm_the_truth_o,
        object: tm_tt_id_t,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).object_asset_name).unsafe_unwrap()(tt, object)
    }

    pub unsafe fn find_directory_settings(
        &self,
        tt: *mut tm_the_truth_o,
        relative_to: tm_tt_id_t,
        target_type_hash: tm_strhash_t,
    ) -> tm_tt_id_t {
        ((*self.0).find_directory_settings).unsafe_unwrap()(tt, relative_to, target_type_hash)
    }

    pub unsafe fn object_to_config(
        &self,
        tt: *const tm_the_truth_o,
        object: tm_tt_id_t,
        config: *mut tm_config_i,
        buffers: *mut *mut tm_tt_assets_buffer_write_t,
        buffers_ta: *mut tm_temp_allocator_i,
        save_uuid: bool,
    ) {
        ((*self.0).object_to_config).unsafe_unwrap()(
            tt, object, config, buffers, buffers_ta, save_uuid,
        )
    }

    pub unsafe fn create_object_from_config(
        &self,
        tt: *mut tm_the_truth_o,
        config: *mut tm_config_i,
        buffers: *mut *mut tm_tt_assets_buffer_t,
        buffers_ta: *mut tm_temp_allocator_i,
    ) -> tm_tt_id_t {
        ((*self.0).create_object_from_config).unsafe_unwrap()(tt, config, buffers, buffers_ta)
    }

    pub unsafe fn read_object_from_config(
        &self,
        tt: *mut tm_the_truth_o,
        config: *mut tm_config_i,
        buffers: *mut *mut tm_tt_assets_buffer_t,
        buffers_ta: *mut tm_temp_allocator_i,
        id: tm_tt_id_t,
    ) {
        ((*self.0).read_object_from_config).unsafe_unwrap()(tt, config, buffers, buffers_ta, id)
    }

    pub unsafe fn save_to_directory(
        &self,
        tt: *mut tm_the_truth_o,
        asset_root: tm_tt_id_t,
        dir: &std::ffi::CStr,
        ignore: *mut tm_tt_id_t,
        num_ignore: u32,
        old_std: *mut tm_saved_truth_data_o,
        allocator: *mut tm_allocator_i,
    ) -> *mut tm_saved_truth_data_o {
        let dir = dir.as_ptr();
        ((*self.0).save_to_directory).unsafe_unwrap()(
            tt, asset_root, dir, ignore, num_ignore, old_std, allocator,
        )
    }

    pub unsafe fn load_from_directory(
        &self,
        tt: *mut tm_the_truth_o,
        dir: &std::ffi::CStr,
        allocator: *mut tm_allocator_i,
        asset_root: *mut tm_tt_id_t,
        error: *mut tm_error_i,
    ) -> *mut tm_saved_truth_data_o {
        let dir = dir.as_ptr();
        ((*self.0).load_from_directory).unsafe_unwrap()(tt, dir, allocator, asset_root, error)
    }

    pub unsafe fn current_truth_data(
        &self,
        tt: *mut tm_the_truth_o,
        asset_root: tm_tt_id_t,
        allocator: *mut tm_allocator_i,
    ) -> *mut tm_saved_truth_data_o {
        ((*self.0).current_truth_data).unsafe_unwrap()(tt, asset_root, allocator)
    }

    pub unsafe fn revert_asset(
        &self,
        sd: *mut tm_saved_truth_data_o,
        asset: tm_tt_id_t,
        undo_scope: tm_tt_undo_scope_t,
    ) -> bool {
        ((*self.0).revert_asset).unsafe_unwrap()(sd, asset, undo_scope)
    }

    pub unsafe fn save_asset(&self, sd: *mut tm_saved_truth_data_o, asset: tm_tt_id_t) -> bool {
        ((*self.0).save_asset).unsafe_unwrap()(sd, asset)
    }

    pub unsafe fn saved_name(
        &self,
        sd: *mut tm_saved_truth_data_o,
        item: tm_tt_id_t,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).saved_name).unsafe_unwrap()(sd, item)
    }

    pub unsafe fn saved_directory(
        &self,
        sd: *mut tm_saved_truth_data_o,
        item: tm_tt_id_t,
    ) -> tm_tt_id_t {
        ((*self.0).saved_directory).unsafe_unwrap()(sd, item)
    }

    pub unsafe fn saved_version(&self, sd: *mut tm_saved_truth_data_o, item: tm_tt_id_t) -> u64 {
        ((*self.0).saved_version).unsafe_unwrap()(sd, item)
    }

    pub unsafe fn all_saved_items(
        &self,
        sd: *mut tm_saved_truth_data_o,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_tt_id_t {
        ((*self.0).all_saved_items).unsafe_unwrap()(sd, ta)
    }

    pub unsafe fn free_saved_data(&self, sd: *mut tm_saved_truth_data_o) {
        ((*self.0).free_saved_data).unsafe_unwrap()(sd)
    }

    pub unsafe fn set_mock_file_system(
        &self,
        fs: *mut tm_os_file_system_api,
        file_io: *mut tm_os_file_io_api,
    ) {
        ((*self.0).set_mock_file_system).unsafe_unwrap()(fs, file_io)
    }

    pub unsafe fn any_disk_changes(
        &self,
        sd: *mut tm_saved_truth_data_o,
        dir: &std::ffi::CStr,
    ) -> bool {
        let dir = dir.as_ptr();
        ((*self.0).any_disk_changes).unsafe_unwrap()(sd, dir)
    }
}

impl crate::Api for TheTruthAssetsApi {
    const NAME: *const i8 = TM_THE_TRUTH_ASSETS_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_the_truth_assets_api)
    }
}
unsafe impl Send for TheTruthAssetsApi {}
unsafe impl Sync for TheTruthAssetsApi {}
pub struct TheTruthMigrationApi(pub *const tm_the_truth_migration_api);

impl TheTruthMigrationApi {
    pub unsafe fn migrate(&self, tt: *mut tm_the_truth_o) -> bool {
        ((*self.0).migrate).unsafe_unwrap()(tt)
    }
}

impl crate::Api for TheTruthMigrationApi {
    const NAME: *const i8 = TM_THE_TRUTH_MIGRATION_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_the_truth_migration_api)
    }
}
unsafe impl Send for TheTruthMigrationApi {}
unsafe impl Sync for TheTruthMigrationApi {}
pub struct TheTruthCommonTypesApi(pub *const tm_the_truth_common_types_api);

impl TheTruthCommonTypesApi {
    pub unsafe fn create_common_types(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).create_common_types).unsafe_unwrap()(tt)
    }

    pub unsafe fn get_vec2(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_vec2_t {
        ((*self.0).get_vec2).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_vec3(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_vec3_t {
        ((*self.0).get_vec3).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_vec4(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_vec4_t {
        ((*self.0).get_vec4).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_rect(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_rect_t {
        ((*self.0).get_rect).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_position(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_vec3_t {
        ((*self.0).get_position).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_rotation(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_vec4_t {
        ((*self.0).get_rotation).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_scale(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_vec3_t {
        ((*self.0).get_scale).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_color_rgb(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_vec3_t {
        ((*self.0).get_color_rgb).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_color_rgba(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_vec4_t {
        ((*self.0).get_color_rgba).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_color_srgb(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_color_srgb_t {
        ((*self.0).get_color_srgb).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn get_color_srgba(
        &self,
        tt: *const tm_the_truth_o,
        object: *const tm_the_truth_object_o,
        property: u32,
    ) -> tm_color_srgb_t {
        ((*self.0).get_color_srgba).unsafe_unwrap()(tt, object, property)
    }

    pub unsafe fn set_vec2(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        vec2: tm_vec2_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_vec2).unsafe_unwrap()(tt, object, property, vec2, undo_scope)
    }

    pub unsafe fn set_vec3(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        vec3: tm_vec3_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_vec3).unsafe_unwrap()(tt, object, property, vec3, undo_scope)
    }

    pub unsafe fn set_vec4(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        vec4: tm_vec4_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_vec4).unsafe_unwrap()(tt, object, property, vec4, undo_scope)
    }

    pub unsafe fn set_rect(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        rect: tm_rect_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_rect).unsafe_unwrap()(tt, object, property, rect, undo_scope)
    }

    pub unsafe fn set_position(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        vec3: tm_vec3_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_position).unsafe_unwrap()(tt, object, property, vec3, undo_scope)
    }

    pub unsafe fn set_rotation(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        vec4: tm_vec4_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_rotation).unsafe_unwrap()(tt, object, property, vec4, undo_scope)
    }

    pub unsafe fn set_scale(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        vec3: tm_vec3_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_scale).unsafe_unwrap()(tt, object, property, vec3, undo_scope)
    }

    pub unsafe fn set_color_rgb(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        vec3: tm_vec3_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_color_rgb).unsafe_unwrap()(tt, object, property, vec3, undo_scope)
    }

    pub unsafe fn set_color_rgba(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        vec4: tm_vec4_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_color_rgba).unsafe_unwrap()(tt, object, property, vec4, undo_scope)
    }

    pub unsafe fn set_color_srgb(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        col: tm_color_srgb_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_color_srgb).unsafe_unwrap()(tt, object, property, col, undo_scope)
    }

    pub unsafe fn set_color_srgba(
        &self,
        tt: *mut tm_the_truth_o,
        object: *mut tm_the_truth_object_o,
        property: u32,
        col: tm_color_srgb_t,
        undo_scope: tm_tt_undo_scope_t,
    ) {
        ((*self.0).set_color_srgba).unsafe_unwrap()(tt, object, property, col, undo_scope)
    }

    pub unsafe fn read_floats(
        &self,
        tt: *const tm_the_truth_o,
        obj: *const tm_the_truth_object_o,
        res: *mut f32,
        n: u32,
    ) -> *mut f32 {
        ((*self.0).read_floats).unsafe_unwrap()(tt, obj, res, n)
    }

    pub unsafe fn write_floats(
        &self,
        tt: *mut tm_the_truth_o,
        obj: *mut tm_the_truth_object_o,
        values: *const f32,
        n: u32,
    ) {
        ((*self.0).write_floats).unsafe_unwrap()(tt, obj, values, n)
    }
}

impl crate::Api for TheTruthCommonTypesApi {
    const NAME: *const i8 = TM_THE_TRUTH_COMMON_TYPES_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_the_truth_common_types_api)
    }
}
unsafe impl Send for TheTruthCommonTypesApi {}
unsafe impl Sync for TheTruthCommonTypesApi {}
pub struct UnicodeApi(pub *const tm_unicode_api);

impl UnicodeApi {
    pub unsafe fn is_valid(&self, utf8: &std::ffi::CStr) -> bool {
        let utf8 = utf8.as_ptr();
        ((*self.0).is_valid).unsafe_unwrap()(utf8)
    }

    pub unsafe fn truncate(&self, utf8: *mut ::std::os::raw::c_char) {
        ((*self.0).truncate).unsafe_unwrap()(utf8)
    }

    pub unsafe fn utf8_encode(
        &self,
        utf8: *mut ::std::os::raw::c_char,
        codepoint: u32,
    ) -> *mut ::std::os::raw::c_char {
        ((*self.0).utf8_encode).unsafe_unwrap()(utf8, codepoint)
    }

    pub unsafe fn utf8_decode(&self, utf8: *mut *const ::std::os::raw::c_char) -> u32 {
        ((*self.0).utf8_decode).unsafe_unwrap()(utf8)
    }

    pub unsafe fn utf8_num_codepoints(&self, utf8: &std::ffi::CStr) -> u32 {
        let utf8 = utf8.as_ptr();
        ((*self.0).utf8_num_codepoints).unsafe_unwrap()(utf8)
    }

    pub unsafe fn utf8_decode_n(&self, codepoints: *mut u32, n: u32, utf8: &std::ffi::CStr) -> u32 {
        let utf8 = utf8.as_ptr();
        ((*self.0).utf8_decode_n).unsafe_unwrap()(codepoints, n, utf8)
    }

    pub unsafe fn utf8_to_utf32(
        &self,
        utf8: &std::ffi::CStr,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut u32 {
        let utf8 = utf8.as_ptr();
        ((*self.0).utf8_to_utf32).unsafe_unwrap()(utf8, ta)
    }

    pub unsafe fn utf8_to_utf32_n(
        &self,
        utf8: &std::ffi::CStr,
        n: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut u32 {
        let utf8 = utf8.as_ptr();
        ((*self.0).utf8_to_utf32_n).unsafe_unwrap()(utf8, n, ta)
    }

    pub unsafe fn utf32_to_utf8(
        &self,
        utf32: *const u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut ::std::os::raw::c_char {
        ((*self.0).utf32_to_utf8).unsafe_unwrap()(utf32, ta)
    }

    pub unsafe fn utf32_to_utf8_n(
        &self,
        utf32: *const u32,
        n: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut ::std::os::raw::c_char {
        ((*self.0).utf32_to_utf8_n).unsafe_unwrap()(utf32, n, ta)
    }

    pub unsafe fn utf16_encode(&self, utf16: *mut u16, codepoint: u32) -> *mut u16 {
        ((*self.0).utf16_encode).unsafe_unwrap()(utf16, codepoint)
    }

    pub unsafe fn utf16_decode(&self, utf16: *mut *const u16) -> u32 {
        ((*self.0).utf16_decode).unsafe_unwrap()(utf16)
    }

    pub unsafe fn utf8_to_utf16(
        &self,
        utf8: &std::ffi::CStr,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut u16 {
        let utf8 = utf8.as_ptr();
        ((*self.0).utf8_to_utf16).unsafe_unwrap()(utf8, ta)
    }

    pub unsafe fn utf8_to_utf16_n(
        &self,
        utf8: &std::ffi::CStr,
        n: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut u16 {
        let utf8 = utf8.as_ptr();
        ((*self.0).utf8_to_utf16_n).unsafe_unwrap()(utf8, n, ta)
    }

    pub unsafe fn utf16_to_utf8(
        &self,
        utf16: *const u16,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut ::std::os::raw::c_char {
        ((*self.0).utf16_to_utf8).unsafe_unwrap()(utf16, ta)
    }

    pub unsafe fn utf16_to_utf8_n(
        &self,
        utf16: *const u16,
        n: u32,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut ::std::os::raw::c_char {
        ((*self.0).utf16_to_utf8_n).unsafe_unwrap()(utf16, n, ta)
    }
}

impl crate::Api for UnicodeApi {
    const NAME: *const i8 = TM_UNICODE_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_unicode_api)
    }
}
unsafe impl Send for UnicodeApi {}
unsafe impl Sync for UnicodeApi {}
pub struct VisibilityFlagsApi(pub *const tm_visibility_flags_api);

impl VisibilityFlagsApi {
    pub unsafe fn create_context(
        &self,
        allocator: *mut tm_allocator_i,
        name: tm_strhash_t,
    ) -> *mut tm_visibility_context_o {
        ((*self.0).create_context).unsafe_unwrap()(allocator, name)
    }

    pub unsafe fn context_name(&self, context: *mut tm_visibility_context_o) -> tm_strhash_t {
        ((*self.0).context_name).unsafe_unwrap()(context)
    }

    pub unsafe fn destroy_context(&self, context: *mut tm_visibility_context_o) {
        ((*self.0).destroy_context).unsafe_unwrap()(context)
    }

    pub unsafe fn register_visibility_flag(
        &self,
        context: *mut tm_visibility_context_o,
        desc: *const tm_visibility_flag_desc_i,
    ) -> u64 {
        ((*self.0).register_visibility_flag).unsafe_unwrap()(context, desc)
    }

    pub unsafe fn name_from_visibility_flag(
        &self,
        context: *mut tm_visibility_context_o,
        visibility_flag: u64,
    ) -> tm_strhash_t {
        ((*self.0).name_from_visibility_flag).unsafe_unwrap()(context, visibility_flag)
    }

    pub unsafe fn visibility_flag_from_name(
        &self,
        context: *mut tm_visibility_context_o,
        name: tm_strhash_t,
    ) -> u64 {
        ((*self.0).visibility_flag_from_name).unsafe_unwrap()(context, name)
    }

    pub unsafe fn unregister_visibility_flag(
        &self,
        context: *mut tm_visibility_context_o,
        uuid: u32,
    ) {
        ((*self.0).unregister_visibility_flag).unsafe_unwrap()(context, uuid)
    }

    pub unsafe fn enumerate_flags(
        &self,
        context: *mut tm_visibility_context_o,
        flags: *mut tm_visibility_flag_desc_i,
        num_flags: *mut u32,
    ) {
        ((*self.0).enumerate_flags).unsafe_unwrap()(context, flags, num_flags)
    }

    pub unsafe fn build_visibility_mask(
        &self,
        context: *mut tm_visibility_context_o,
        uuids: *const u32,
        num_uuids: u32,
    ) -> u64 {
        ((*self.0).build_visibility_mask).unsafe_unwrap()(context, uuids, num_uuids)
    }
}

impl crate::Api for VisibilityFlagsApi {
    const NAME: *const i8 = TM_VISIBILITY_FLAGS_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_visibility_flags_api)
    }
}
unsafe impl Send for VisibilityFlagsApi {}
unsafe impl Sync for VisibilityFlagsApi {}
pub struct WebSocketProtocolApi(pub *const tm_web_socket_protocol_api);

impl WebSocketProtocolApi {
    pub unsafe fn make_client_handshake(
        &self,
        buffer: *mut ::std::os::raw::c_char,
        size: u32,
        host: &std::ffi::CStr,
        port: u32,
        request: &std::ffi::CStr,
        key: &std::ffi::CStr,
    ) {
        let host = host.as_ptr();
        let request = request.as_ptr();
        let key = key.as_ptr();
        ((*self.0).make_client_handshake).unsafe_unwrap()(buffer, size, host, port, request, key)
    }

    pub unsafe fn make_server_handshake(
        &self,
        buffer: *mut ::std::os::raw::c_char,
        size: u32,
        key: &std::ffi::CStr,
        key_size: u32,
    ) {
        let key = key.as_ptr();
        ((*self.0).make_server_handshake).unsafe_unwrap()(buffer, size, key, key_size)
    }

    pub unsafe fn make_frame_header(
        &self,
        buffer: *mut u8,
        fin: bool,
        opcode: u8,
        size: u64,
        mask: u32,
    ) -> u32 {
        ((*self.0).make_frame_header).unsafe_unwrap()(buffer, fin, opcode, size, mask)
    }

    pub unsafe fn parse_frame_header(
        &self,
        buffer: *mut u8,
        buf_size: u64,
        fin: *mut bool,
        opcode: *mut u8,
        size: *mut u64,
        mask: *mut u32,
    ) -> u32 {
        ((*self.0).parse_frame_header).unsafe_unwrap()(buffer, buf_size, fin, opcode, size, mask)
    }

    pub unsafe fn mask_data(&self, data: *mut u8, size: u64, offset: u64, mask: u32) {
        ((*self.0).mask_data).unsafe_unwrap()(data, size, offset, mask)
    }

    pub unsafe fn mask_segmented_buffer(
        &self,
        seg: *mut tm_segmented_buffer_t,
        size: u64,
        mask: u32,
    ) {
        ((*self.0).mask_segmented_buffer).unsafe_unwrap()(seg, size, mask)
    }
}

impl crate::Api for WebSocketProtocolApi {
    const NAME: *const i8 = TM_WEB_SOCKET_PROTOCOL_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_web_socket_protocol_api)
    }
}
unsafe impl Send for WebSocketProtocolApi {}
unsafe impl Sync for WebSocketProtocolApi {}
pub struct WebTalkerApi(pub *const tm_web_talker_api);

impl WebTalkerApi {
    pub unsafe fn create(
        &self,
        a: *mut tm_allocator_i,
        socket: *mut tm_os_socket_api,
        port: u32,
    ) -> *mut tm_web_talker_o {
        ((*self.0).create).unsafe_unwrap()(a, socket, port)
    }

    pub unsafe fn listening_address(
        &self,
        inst: *mut tm_web_talker_o,
        address: *mut tm_socket_address_t,
    ) -> bool {
        ((*self.0).listening_address).unsafe_unwrap()(inst, address)
    }

    pub unsafe fn create_no_server(
        &self,
        a: *mut tm_allocator_i,
        socket: *mut tm_os_socket_api,
    ) -> *mut tm_web_talker_o {
        ((*self.0).create_no_server).unsafe_unwrap()(a, socket)
    }

    pub unsafe fn destroy(&self, arg1: *mut tm_web_talker_o) {
        ((*self.0).destroy).unsafe_unwrap()(arg1)
    }

    pub unsafe fn receive(&self, inst: *mut tm_web_talker_o) {
        ((*self.0).receive).unsafe_unwrap()(inst)
    }

    pub unsafe fn send(&self, inst: *mut tm_web_talker_o) {
        ((*self.0).send).unsafe_unwrap()(inst)
    }

    pub unsafe fn http_get_requests(
        &self,
        inst: *mut tm_web_talker_o,
        buffer: *mut tm_http_request_t,
        capacity: u32,
    ) -> u32 {
        ((*self.0).http_get_requests).unsafe_unwrap()(inst, buffer, capacity)
    }

    pub unsafe fn http_respond_raw(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
        response: &std::ffi::CStr,
    ) {
        let response = response.as_ptr();
        ((*self.0).http_respond_raw).unsafe_unwrap()(inst, id, response)
    }

    pub unsafe fn http_respond_html(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
        html: &std::ffi::CStr,
    ) {
        let html = html.as_ptr();
        ((*self.0).http_respond_html).unsafe_unwrap()(inst, id, html)
    }

    pub unsafe fn http_request(
        &self,
        inst: *mut tm_web_talker_o,
        address: tm_socket_address_t,
        headers: &std::ffi::CStr,
    ) -> u64 {
        let headers = headers.as_ptr();
        ((*self.0).http_request).unsafe_unwrap()(inst, address, headers)
    }

    pub unsafe fn http_request_status(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
    ) -> tm_http_request_status {
        ((*self.0).http_request_status).unsafe_unwrap()(inst, id)
    }

    pub unsafe fn http_response(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
        size: *mut u64,
    ) -> tm_segmented_buffer_t {
        ((*self.0).http_response).unsafe_unwrap()(inst, id, size)
    }

    pub unsafe fn http_close(&self, inst: *mut tm_web_talker_o, id: u64) {
        ((*self.0).http_close).unsafe_unwrap()(inst, id)
    }

    pub unsafe fn ws_connect(
        &self,
        inst: *mut tm_web_talker_o,
        address: tm_socket_address_t,
        host: &std::ffi::CStr,
        request: &std::ffi::CStr,
    ) -> u64 {
        let host = host.as_ptr();
        let request = request.as_ptr();
        ((*self.0).ws_connect).unsafe_unwrap()(inst, address, host, request)
    }

    pub unsafe fn ws_get_requests(
        &self,
        inst: *mut tm_web_talker_o,
        buffer: *mut tm_web_socket_request_t,
        capacity: u32,
    ) -> u32 {
        ((*self.0).ws_get_requests).unsafe_unwrap()(inst, buffer, capacity)
    }

    pub unsafe fn ws_status(&self, inst: *mut tm_web_talker_o, id: u64) -> tm_web_socket_status {
        ((*self.0).ws_status).unsafe_unwrap()(inst, id)
    }

    pub unsafe fn ws_recv_progress(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
        bytes: *mut u64,
        total: *mut u64,
    ) -> bool {
        ((*self.0).ws_recv_progress).unsafe_unwrap()(inst, id, bytes, total)
    }

    pub unsafe fn ws_get_events(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
        buffer: *mut tm_web_socket_event_t,
        capacity: u32,
    ) -> u32 {
        ((*self.0).ws_get_events).unsafe_unwrap()(inst, id, buffer, capacity)
    }

    pub unsafe fn ws_send_text_frame(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
        s: &std::ffi::CStr,
    ) {
        let s = s.as_ptr();
        ((*self.0).ws_send_text_frame).unsafe_unwrap()(inst, id, s)
    }

    pub unsafe fn ws_send_binary_frame(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
        data: *const u8,
        size: u64,
    ) {
        ((*self.0).ws_send_binary_frame).unsafe_unwrap()(inst, id, data, size)
    }

    pub unsafe fn ws_send_segmented_binary_frame(
        &self,
        inst: *mut tm_web_talker_o,
        id: u64,
        buf: *const tm_segmented_buffer_t,
        size: u64,
    ) {
        ((*self.0).ws_send_segmented_binary_frame).unsafe_unwrap()(inst, id, buf, size)
    }

    pub unsafe fn ws_send_ping(&self, inst: *mut tm_web_talker_o, id: u64) {
        ((*self.0).ws_send_ping).unsafe_unwrap()(inst, id)
    }

    pub unsafe fn ws_close(&self, inst: *mut tm_web_talker_o, id: u64) {
        ((*self.0).ws_close).unsafe_unwrap()(inst, id)
    }

    pub unsafe fn copy_segmented_buffer(
        &self,
        buffer: *mut ::std::os::raw::c_void,
        segments: *const tm_segmented_buffer_t,
        size: u64,
    ) {
        ((*self.0).copy_segmented_buffer).unsafe_unwrap()(buffer, segments, size)
    }
}

impl crate::Api for WebTalkerApi {
    const NAME: *const i8 = TM_WEB_TALKER_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_web_talker_api)
    }
}
unsafe impl Send for WebTalkerApi {}
unsafe impl Sync for WebTalkerApi {}
pub struct RenderPipelineApi(pub *const tm_render_pipeline_api);

impl RenderPipelineApi {}

unsafe impl Send for RenderPipelineApi {}
unsafe impl Sync for RenderPipelineApi {}
