// Code generated by machinery's build.rs

use machinery_sys::foundation::*;
use unsafe_unwrap::UnsafeUnwrap;

pub struct ApiRegistryApi(pub *const tm_api_registry_api);

impl ApiRegistryApi {
    pub unsafe fn set(&self, name: &str, api: *const ::std::os::raw::c_void, bytes: u32) {
        let name = std::ffi::CString::new(name).unwrap();
        ((*self.0).set).unsafe_unwrap()(name.as_ptr(), api, bytes)
    }

    pub unsafe fn remove(&self, api: *const ::std::os::raw::c_void) {
        ((*self.0).remove).unsafe_unwrap()(api)
    }

    pub unsafe fn get(&self, name: &str) -> *mut ::std::os::raw::c_void {
        let name = std::ffi::CString::new(name).unwrap();
        ((*self.0).get).unsafe_unwrap()(name.as_ptr())
    }

    pub unsafe fn get_optional(&self, name: &str) -> *mut ::std::os::raw::c_void {
        let name = std::ffi::CString::new(name).unwrap();
        ((*self.0).get_optional).unsafe_unwrap()(name.as_ptr())
    }

    pub unsafe fn add_implementation(
        &self,
        name: &str,
        implementation: *const ::std::os::raw::c_void,
    ) {
        let name = std::ffi::CString::new(name).unwrap();
        ((*self.0).add_implementation).unsafe_unwrap()(name.as_ptr(), implementation)
    }

    pub unsafe fn remove_implementation(
        &self,
        name: &str,
        implementation: *const ::std::os::raw::c_void,
    ) {
        let name = std::ffi::CString::new(name).unwrap();
        ((*self.0).remove_implementation).unsafe_unwrap()(name.as_ptr(), implementation)
    }

    pub unsafe fn implementations(
        &self,
        name: &str,
        count: *mut u32,
    ) -> *mut *mut ::std::os::raw::c_void {
        let name = std::ffi::CString::new(name).unwrap();
        ((*self.0).implementations).unsafe_unwrap()(name.as_ptr(), count)
    }

    pub unsafe fn add_listener(&self, listener: *const tm_api_registry_listener_i) {
        ((*self.0).add_listener).unsafe_unwrap()(listener)
    }

    pub unsafe fn static_variable(
        &self,
        id: tm_strhash_t,
        size: u32,
        file: &str,
        line: u32,
    ) -> *mut ::std::os::raw::c_void {
        let file = std::ffi::CString::new(file).unwrap();
        ((*self.0).static_variable).unsafe_unwrap()(id, size, file.as_ptr(), line)
    }

    pub unsafe fn log_missing_apis(&self) {
        ((*self.0).log_missing_apis).unsafe_unwrap()()
    }
}

impl crate::foundation::RegistryApi for ApiRegistryApi {
    const NAME: &'static str = "tm_api_registry_api";
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_api_registry_api)
    }
}
pub struct LoggerApi(pub *const tm_logger_api);

impl LoggerApi {
    pub unsafe fn add_logger(&self, logger: *const tm_logger_i) {
        ((*self.0).add_logger).unsafe_unwrap()(logger)
    }

    pub unsafe fn remove_logger(&self, logger: *const tm_logger_i) {
        ((*self.0).remove_logger).unsafe_unwrap()(logger)
    }

    pub unsafe fn print(&self, log_type: tm_log_type, msg: &str) {
        let msg = std::ffi::CString::new(msg).unwrap();
        ((*self.0).print).unsafe_unwrap()(log_type, msg.as_ptr())
    }

    pub unsafe fn printf(&self, log_type: tm_log_type, format: &str) -> ::std::os::raw::c_int {
        let format = std::ffi::CString::new(format).unwrap();
        ((*self.0).printf).unsafe_unwrap()(log_type, format.as_ptr())
    }
}

impl crate::foundation::RegistryApi for LoggerApi {
    const NAME: &'static str = "tm_logger_api";
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_logger_api)
    }
}
