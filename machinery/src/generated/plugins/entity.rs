// Code generated by machinery's build.rs

use machinery_sys::plugins::entity::*;
use unsafe_unwrap::UnsafeUnwrap;

pub struct EntityApi(pub *const tm_entity_api);

impl EntityApi {
    pub unsafe fn create_truth_types(&self, tt: *mut tm_the_truth_o) {
        ((*self.0).create_truth_types).unsafe_unwrap()(tt)
    }

    pub unsafe fn create_context(
        &self,
        a: *mut tm_allocator_i,
        tt: *mut tm_the_truth_o,
        create_components: tm_entity_create_components,
    ) -> *mut tm_entity_context_o {
        ((*self.0).create_context).unsafe_unwrap()(a, tt, create_components)
    }

    pub unsafe fn destroy_context(&self, ctx: *mut tm_entity_context_o) {
        ((*self.0).destroy_context).unsafe_unwrap()(ctx)
    }

    pub unsafe fn register_component(
        &self,
        ctx: *mut tm_entity_context_o,
        com: *const tm_component_i,
    ) -> tm_component_type_t {
        ((*self.0).register_component).unsafe_unwrap()(ctx, com)
    }

    pub unsafe fn num_components(&self, ctx: *mut tm_entity_context_o) -> u32 {
        ((*self.0).num_components).unsafe_unwrap()(ctx)
    }

    pub unsafe fn component(
        &self,
        ctx: *mut tm_entity_context_o,
        component_type: tm_component_type_t,
    ) -> *const tm_component_i {
        ((*self.0).component).unsafe_unwrap()(ctx, component_type)
    }

    pub unsafe fn register_engine(
        &self,
        ctx: *mut tm_entity_context_o,
        engine: *const tm_engine_i,
    ) {
        ((*self.0).register_engine).unsafe_unwrap()(ctx, engine)
    }

    pub unsafe fn registered_engines(
        &self,
        ctx: *mut tm_entity_context_o,
        count: *mut u32,
    ) -> *mut tm_engine_i {
        ((*self.0).registered_engines).unsafe_unwrap()(ctx, count)
    }

    pub unsafe fn register_system(
        &self,
        ctx: *mut tm_entity_context_o,
        system: *const tm_entity_system_i,
    ) {
        ((*self.0).register_system).unsafe_unwrap()(ctx, system)
    }

    pub unsafe fn registered_systems(
        &self,
        ctx: *mut tm_entity_context_o,
        count: *mut u32,
    ) -> *mut tm_entity_system_i {
        ((*self.0).registered_systems).unsafe_unwrap()(ctx, count)
    }

    pub unsafe fn create_child_allocator(
        &self,
        ctx: *mut tm_entity_context_o,
        name: &str,
        a: *mut tm_allocator_i,
    ) {
        let name = std::ffi::CString::new(name).unwrap();
        ((*self.0).create_child_allocator).unsafe_unwrap()(ctx, name.as_ptr(), a)
    }

    pub unsafe fn destroy_child_allocator(
        &self,
        ctx: *mut tm_entity_context_o,
        a: *mut tm_allocator_i,
    ) {
        ((*self.0).destroy_child_allocator).unsafe_unwrap()(ctx, a)
    }

    pub unsafe fn the_truth(&self, ctx: *mut tm_entity_context_o) -> *mut tm_the_truth_o {
        ((*self.0).the_truth).unsafe_unwrap()(ctx)
    }

    pub unsafe fn create_entity(&self, ctx: *mut tm_entity_context_o) -> tm_entity_t {
        ((*self.0).create_entity).unsafe_unwrap()(ctx)
    }

    pub unsafe fn batch_create_entity(
        &self,
        ctx: *mut tm_entity_context_o,
        es: *mut tm_entity_t,
        n: u32,
    ) {
        ((*self.0).batch_create_entity).unsafe_unwrap()(ctx, es, n)
    }

    pub unsafe fn create_entity_from_mask(
        &self,
        ctx: *mut tm_entity_context_o,
        mask: *const tm_component_mask_t,
    ) -> tm_entity_t {
        ((*self.0).create_entity_from_mask).unsafe_unwrap()(ctx, mask)
    }

    pub unsafe fn batch_create_entity_from_mask(
        &self,
        ctx: *mut tm_entity_context_o,
        mask: *const tm_component_mask_t,
        es: *mut tm_entity_t,
        n: u32,
    ) {
        ((*self.0).batch_create_entity_from_mask).unsafe_unwrap()(ctx, mask, es, n)
    }

    pub unsafe fn create_entity_from_asset(
        &self,
        ctx: *mut tm_entity_context_o,
        asset: tm_tt_id_t,
    ) -> tm_entity_t {
        ((*self.0).create_entity_from_asset).unsafe_unwrap()(ctx, asset)
    }

    pub unsafe fn batch_create_entity_from_asset(
        &self,
        ctx: *mut tm_entity_context_o,
        asset: tm_tt_id_t,
        es: *mut tm_entity_t,
        n: u32,
    ) {
        ((*self.0).batch_create_entity_from_asset).unsafe_unwrap()(ctx, asset, es, n)
    }

    pub unsafe fn destroy_entity(&self, ctx: *mut tm_entity_context_o, e: tm_entity_t) {
        ((*self.0).destroy_entity).unsafe_unwrap()(ctx, e)
    }

    pub unsafe fn batch_destroy_entity(
        &self,
        ctx: *mut tm_entity_context_o,
        es: *const tm_entity_t,
        n: u32,
    ) {
        ((*self.0).batch_destroy_entity).unsafe_unwrap()(ctx, es, n)
    }

    pub unsafe fn destroy_all_entities(&self, ctx: *mut tm_entity_context_o) {
        ((*self.0).destroy_all_entities).unsafe_unwrap()(ctx)
    }

    pub unsafe fn queue_destroy_entities(
        &self,
        ctx: *mut tm_entity_context_o,
        es: *const tm_entity_t,
        n: u32,
    ) {
        ((*self.0).queue_destroy_entities).unsafe_unwrap()(ctx, es, n)
    }

    pub unsafe fn is_alive(&self, ctx: *mut tm_entity_context_o, e: tm_entity_t) -> bool {
        ((*self.0).is_alive).unsafe_unwrap()(ctx, e)
    }

    pub unsafe fn num_entities(&self, ctx: *mut tm_entity_context_o) -> u32 {
        ((*self.0).num_entities).unsafe_unwrap()(ctx)
    }

    pub unsafe fn entities_matching(
        &self,
        ctx: *mut tm_entity_context_o,
        required: *const tm_component_mask_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_entity_set_t {
        ((*self.0).entities_matching).unsafe_unwrap()(ctx, required, ta)
    }

    pub unsafe fn entities_matching_with_forbidden(
        &self,
        ctx: *mut tm_entity_context_o,
        required: *const tm_component_mask_t,
        forbidden: *const tm_component_mask_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_entity_set_t {
        ((*self.0).entities_matching_with_forbidden).unsafe_unwrap()(ctx, required, forbidden, ta)
    }

    pub unsafe fn flatten_set(&self, entities: *mut tm_entity_t, set: *const tm_entity_set_t) {
        ((*self.0).flatten_set).unsafe_unwrap()(entities, set)
    }

    pub unsafe fn lookup_component_type(
        &self,
        ctx: *mut tm_entity_context_o,
        name_hash: tm_strhash_t,
    ) -> tm_component_type_t {
        ((*self.0).lookup_component_type).unsafe_unwrap()(ctx, name_hash)
    }

    pub unsafe fn component_manager(
        &self,
        ctx: *mut tm_entity_context_o,
        component_type: tm_component_type_t,
    ) -> *mut tm_component_manager_o {
        ((*self.0).component_manager).unsafe_unwrap()(ctx, component_type)
    }

    pub unsafe fn component_manager_by_hash(
        &self,
        ctx: *mut tm_entity_context_o,
        name_hash: tm_strhash_t,
    ) -> *mut tm_component_manager_o {
        ((*self.0).component_manager_by_hash).unsafe_unwrap()(ctx, name_hash)
    }

    pub unsafe fn create_component_mask(
        &self,
        components: *const tm_component_type_t,
        n: u32,
    ) -> tm_component_mask_t {
        ((*self.0).create_component_mask).unsafe_unwrap()(components, n)
    }

    pub unsafe fn component_mask(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
    ) -> *const tm_component_mask_t {
        ((*self.0).component_mask).unsafe_unwrap()(ctx, e)
    }

    pub unsafe fn add_component(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        component: tm_component_type_t,
    ) -> *mut ::std::os::raw::c_void {
        ((*self.0).add_component).unsafe_unwrap()(ctx, e, component)
    }

    pub unsafe fn get_component(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        component: tm_component_type_t,
    ) -> *mut ::std::os::raw::c_void {
        ((*self.0).get_component).unsafe_unwrap()(ctx, e, component)
    }

    pub unsafe fn get_component_by_hash(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        name_hash: tm_strhash_t,
    ) -> *mut ::std::os::raw::c_void {
        ((*self.0).get_component_by_hash).unsafe_unwrap()(ctx, e, name_hash)
    }

    pub unsafe fn remove_component(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        component: tm_component_type_t,
    ) {
        ((*self.0).remove_component).unsafe_unwrap()(ctx, e, component)
    }

    pub unsafe fn call_remove_on_all_entities(
        &self,
        ctx: *mut tm_entity_context_o,
        component: tm_component_type_t,
    ) {
        ((*self.0).call_remove_on_all_entities).unsafe_unwrap()(ctx, component)
    }

    pub unsafe fn get_engine(
        &self,
        ctx: *mut tm_entity_context_o,
        hash: tm_strhash_t,
    ) -> *mut tm_engine_i {
        ((*self.0).get_engine).unsafe_unwrap()(ctx, hash)
    }

    pub unsafe fn get_system(
        &self,
        ctx: *mut tm_entity_context_o,
        hash: tm_strhash_t,
    ) -> *mut tm_entity_system_i {
        ((*self.0).get_system).unsafe_unwrap()(ctx, hash)
    }

    pub unsafe fn parent(&self, ctx: *mut tm_entity_context_o, e: tm_entity_t) -> tm_entity_t {
        ((*self.0).parent).unsafe_unwrap()(ctx, e)
    }

    pub unsafe fn children(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_entity_t {
        ((*self.0).children).unsafe_unwrap()(ctx, e, ta)
    }

    pub unsafe fn asset(&self, ctx: *mut tm_entity_context_o, e: tm_entity_t) -> tm_tt_id_t {
        ((*self.0).asset).unsafe_unwrap()(ctx, e)
    }

    pub unsafe fn find_entity_from_asset(
        &self,
        ctx: *mut tm_entity_context_o,
        asset: tm_tt_id_t,
    ) -> tm_entity_t {
        ((*self.0).find_entity_from_asset).unsafe_unwrap()(ctx, asset)
    }

    pub unsafe fn resolve_asset_reference(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        asset: tm_tt_id_t,
    ) -> tm_entity_t {
        ((*self.0).resolve_asset_reference).unsafe_unwrap()(ctx, e, asset)
    }

    pub unsafe fn resolve_path(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        path: &str,
    ) -> tm_entity_t {
        let path = std::ffi::CString::new(path).unwrap();
        ((*self.0).resolve_path).unsafe_unwrap()(ctx, e, path.as_ptr())
    }

    pub unsafe fn propagate_asset_changes(&self, ctx: *mut tm_entity_context_o) {
        ((*self.0).propagate_asset_changes).unsafe_unwrap()(ctx)
    }

    pub unsafe fn propagate_listen_to(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        object: tm_tt_id_t,
    ) {
        ((*self.0).propagate_listen_to).unsafe_unwrap()(ctx, e, object)
    }

    pub unsafe fn set_blackboard_double(
        &self,
        ctx: *mut tm_entity_context_o,
        id: tm_strhash_t,
        value: f64,
    ) {
        ((*self.0).set_blackboard_double).unsafe_unwrap()(ctx, id, value)
    }

    pub unsafe fn set_blackboard_ptr(
        &self,
        ctx: *mut tm_entity_context_o,
        id: tm_strhash_t,
        value: *mut ::std::os::raw::c_void,
    ) {
        ((*self.0).set_blackboard_ptr).unsafe_unwrap()(ctx, id, value)
    }

    pub unsafe fn has_blackboard(&self, ctx: *mut tm_entity_context_o, id: tm_strhash_t) -> bool {
        ((*self.0).has_blackboard).unsafe_unwrap()(ctx, id)
    }

    pub unsafe fn get_blackboard_double(
        &self,
        ctx: *mut tm_entity_context_o,
        id: tm_strhash_t,
        def: f64,
    ) -> f64 {
        ((*self.0).get_blackboard_double).unsafe_unwrap()(ctx, id, def)
    }

    pub unsafe fn get_blackboard_ptr(
        &self,
        ctx: *mut tm_entity_context_o,
        id: tm_strhash_t,
    ) -> *mut ::std::os::raw::c_void {
        ((*self.0).get_blackboard_ptr).unsafe_unwrap()(ctx, id)
    }

    pub unsafe fn run_engine(&self, ctx: *mut tm_entity_context_o, engine: *const tm_engine_i) {
        ((*self.0).run_engine).unsafe_unwrap()(ctx, engine)
    }

    pub unsafe fn update(&self, ctx: *mut tm_entity_context_o) {
        ((*self.0).update).unsafe_unwrap()(ctx)
    }

    pub unsafe fn listen(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        c: tm_component_type_t,
        listener: *const tm_entity_listener_i,
    ) {
        ((*self.0).listen).unsafe_unwrap()(ctx, e, c, listener)
    }

    pub unsafe fn unlisten(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        c: tm_component_type_t,
        listener: *const tm_entity_listener_i,
    ) {
        ((*self.0).unlisten).unsafe_unwrap()(ctx, e, c, listener)
    }

    pub unsafe fn notify(
        &self,
        ctx: *mut tm_entity_context_o,
        component_type: tm_component_type_t,
        entities: *const tm_entity_t,
        num_entities: u32,
    ) {
        ((*self.0).notify).unsafe_unwrap()(ctx, component_type, entities, num_entities)
    }

    pub unsafe fn listen_event(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        event: tm_strhash_t,
        listener: *const tm_entity_event_listener_i,
    ) {
        ((*self.0).listen_event).unsafe_unwrap()(ctx, e, event, listener)
    }

    pub unsafe fn unlisten_event(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        event: tm_strhash_t,
        listener: *const tm_entity_event_listener_i,
    ) {
        ((*self.0).unlisten_event).unsafe_unwrap()(ctx, e, event, listener)
    }

    pub unsafe fn unlisten_all(
        &self,
        ctx: *mut tm_entity_context_o,
        instance: *mut ::std::os::raw::c_void,
    ) {
        ((*self.0).unlisten_all).unsafe_unwrap()(ctx, instance)
    }

    pub unsafe fn notify_event(
        &self,
        ctx: *mut tm_entity_context_o,
        event: tm_strhash_t,
        e: *mut tm_entity_t,
        entity_stride: u32,
        data: *mut ::std::os::raw::c_void,
        data_stride: u32,
        n: u32,
    ) {
        ((*self.0).notify_event).unsafe_unwrap()(ctx, event, e, entity_stride, data, data_stride, n)
    }

    pub unsafe fn hot_reload(&self) {
        ((*self.0).hot_reload).unsafe_unwrap()()
    }

    pub unsafe fn set_debug_draw(
        &self,
        ctx: *mut tm_entity_context_o,
        component_type: tm_component_type_t,
        tag: tm_strhash_t,
        debug_draw: bool,
    ) {
        ((*self.0).set_debug_draw).unsafe_unwrap()(ctx, component_type, tag, debug_draw)
    }

    pub unsafe fn has_debug_draw(
        &self,
        ctx: *mut tm_entity_context_o,
        component_type: tm_component_type_t,
        tag: tm_strhash_t,
    ) -> bool {
        ((*self.0).has_debug_draw).unsafe_unwrap()(ctx, component_type, tag)
    }

    pub unsafe fn clear_debug_draw(&self, ctx: *mut tm_entity_context_o) {
        ((*self.0).clear_debug_draw).unsafe_unwrap()(ctx)
    }

    pub unsafe fn debug_draw(
        &self,
        ctx: *mut tm_entity_context_o,
        pbuf: *mut tm_primitive_drawer_buffer_t,
        vbuf: *mut tm_primitive_drawer_buffer_t,
        allocator: *mut tm_allocator_i,
        camera: *const tm_camera_t,
        viewport: tm_rect_t,
    ) {
        ((*self.0).debug_draw).unsafe_unwrap()(ctx, pbuf, vbuf, allocator, camera, viewport)
    }

    pub unsafe fn gamestate(&self, ctx: *mut tm_entity_context_o) -> *mut tm_gamestate_o {
        ((*self.0).gamestate).unsafe_unwrap()(ctx)
    }

    pub unsafe fn override_component_persistence(
        &self,
        ctx: *mut tm_entity_context_o,
        c: tm_component_type_t,
        persistence: *mut tm_component_persistence_i,
    ) {
        ((*self.0).override_component_persistence).unsafe_unwrap()(ctx, c, persistence)
    }

    pub unsafe fn propagate_changes_to_gamestate(&self, ctx: *mut tm_entity_context_o) {
        ((*self.0).propagate_changes_to_gamestate).unsafe_unwrap()(ctx)
    }

    pub unsafe fn make_entity_persistent(&self, ctx: *mut tm_entity_context_o, e: tm_entity_t) {
        ((*self.0).make_entity_persistent).unsafe_unwrap()(ctx, e)
    }

    pub unsafe fn get_entity_gamestate_id(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        output: *mut tm_gamestate_object_id_t,
    ) -> bool {
        ((*self.0).get_entity_gamestate_id).unsafe_unwrap()(ctx, e, output)
    }

    pub unsafe fn get_component_gamestate_id(
        &self,
        ctx: *mut tm_entity_context_o,
        e: tm_entity_t,
        c: tm_component_type_t,
        output: *mut tm_gamestate_struct_id_t,
    ) -> bool {
        ((*self.0).get_component_gamestate_id).unsafe_unwrap()(ctx, e, c, output)
    }

    pub unsafe fn lookup_entity_from_gamestate_id(
        &self,
        ctx: *mut tm_entity_context_o,
        id: *const tm_gamestate_object_id_t,
    ) -> tm_entity_t {
        ((*self.0).lookup_entity_from_gamestate_id).unsafe_unwrap()(ctx, id)
    }
}

impl crate::Api for EntityApi {
    const NAME: *const i8 = TM_ENTITY_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_entity_api)
    }
}
unsafe impl Send for EntityApi {}
unsafe impl Sync for EntityApi {}
pub struct OwnerComponentApi(pub *const tm_owner_component_api);

impl OwnerComponentApi {
    pub unsafe fn children(
        &self,
        manager: *const tm_owner_component_manager_o,
        c: *const tm_owner_component_t,
        children: *mut tm_entity_t,
    ) {
        ((*self.0).children).unsafe_unwrap()(manager, c, children)
    }

    pub unsafe fn add_children(
        &self,
        manager: *mut tm_owner_component_manager_o,
        c: *mut tm_owner_component_t,
        e: *const tm_entity_t,
        n: u32,
    ) {
        ((*self.0).add_children).unsafe_unwrap()(manager, c, e, n)
    }

    pub unsafe fn remove_children(
        &self,
        manager: *mut tm_owner_component_manager_o,
        c: *mut tm_owner_component_t,
        e: *const tm_entity_t,
        n: u32,
    ) {
        ((*self.0).remove_children).unsafe_unwrap()(manager, c, e, n)
    }

    pub unsafe fn remove_all_children(
        &self,
        manager: *mut tm_owner_component_manager_o,
        c: *mut tm_owner_component_t,
    ) {
        ((*self.0).remove_all_children).unsafe_unwrap()(manager, c)
    }

    pub unsafe fn descendants(
        &self,
        manager: *const tm_owner_component_manager_o,
        c: *const tm_owner_component_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_entity_t {
        ((*self.0).descendants).unsafe_unwrap()(manager, c, ta)
    }
}

impl crate::Api for OwnerComponentApi {
    const NAME: *const i8 = TM_OWNER_COMPONENT_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_owner_component_api)
    }
}
unsafe impl Send for OwnerComponentApi {}
unsafe impl Sync for OwnerComponentApi {}
pub struct SceneTreeComponentApi(pub *const tm_scene_tree_component_api);

impl SceneTreeComponentApi {
    pub unsafe fn setup_nodes(
        &self,
        manager: *mut tm_scene_tree_component_manager_o,
        st: *mut tm_scene_tree_component_t,
        nodes: *const tm_scene_tree_node_t,
        num_nodes: u32,
        debug_names: &str,
    ) {
        let debug_names = std::ffi::CString::new(debug_names).unwrap();
        ((*self.0).setup_nodes).unsafe_unwrap()(manager, st, nodes, num_nodes, debug_names.as_ptr())
    }

    pub unsafe fn node_names(
        &self,
        st: *const tm_scene_tree_component_t,
    ) -> tm_scene_tree_node_names_t {
        ((*self.0).node_names).unsafe_unwrap()(st)
    }

    pub unsafe fn node_index_from_name(
        &self,
        component: *const tm_scene_tree_component_t,
        node_name: tm_strhash_t,
        not_found: u32,
    ) -> u32 {
        ((*self.0).node_index_from_name).unsafe_unwrap()(component, node_name, not_found)
    }

    pub unsafe fn node_debug_name_from_index(
        &self,
        component: *const tm_scene_tree_component_t,
        node_idx: u32,
    ) -> *const ::std::os::raw::c_char {
        ((*self.0).node_debug_name_from_index).unsafe_unwrap()(component, node_idx)
    }

    pub unsafe fn world_matrices(
        &self,
        component: *const tm_scene_tree_component_t,
    ) -> *const tm_mat44_t {
        ((*self.0).world_matrices).unsafe_unwrap()(component)
    }

    pub unsafe fn local_matrices(
        &self,
        component: *const tm_scene_tree_component_t,
    ) -> *const tm_mat44_t {
        ((*self.0).local_matrices).unsafe_unwrap()(component)
    }

    pub unsafe fn local_transform(
        &self,
        component: *const tm_scene_tree_component_t,
        node_idx: u32,
    ) -> tm_transform_t {
        ((*self.0).local_transform).unsafe_unwrap()(component, node_idx)
    }

    pub unsafe fn world_transform(
        &self,
        component: *const tm_scene_tree_component_t,
        node_idx: u32,
    ) -> tm_transform_t {
        ((*self.0).world_transform).unsafe_unwrap()(component, node_idx)
    }

    pub unsafe fn set_local_transform(
        &self,
        component: *mut tm_scene_tree_component_t,
        node_idx: u32,
        t: *const tm_transform_t,
    ) {
        ((*self.0).set_local_transform).unsafe_unwrap()(component, node_idx, t)
    }

    pub unsafe fn set_local_matrix(
        &self,
        component: *mut tm_scene_tree_component_t,
        node_idx: u32,
        tm: *const tm_mat44_t,
    ) {
        ((*self.0).set_local_matrix).unsafe_unwrap()(component, node_idx, tm)
    }

    pub unsafe fn set_world_transform(
        &self,
        component: *mut tm_scene_tree_component_t,
        trans: *const tm_transform_t,
        node_idx: u32,
        t: *const tm_transform_t,
    ) {
        ((*self.0).set_world_transform).unsafe_unwrap()(component, trans, node_idx, t)
    }

    pub unsafe fn transform(
        &self,
        st: *mut tm_scene_tree_component_t,
        trans: *const tm_transform_t,
        version: u64,
    ) {
        ((*self.0).transform).unsafe_unwrap()(st, trans, version)
    }

    pub unsafe fn transform_subtree(&self, st: *mut tm_scene_tree_component_t, node_idx: u32) {
        ((*self.0).transform_subtree).unsafe_unwrap()(st, node_idx)
    }

    pub unsafe fn set_debug_color(
        &self,
        st: *mut tm_scene_tree_component_t,
        color: tm_color_srgb_t,
    ) {
        ((*self.0).set_debug_color).unsafe_unwrap()(st, color)
    }

    pub unsafe fn node_parent_index(
        &self,
        st: *mut tm_scene_tree_component_t,
        node_idx: u32,
    ) -> u32 {
        ((*self.0).node_parent_index).unsafe_unwrap()(st, node_idx)
    }
}

impl crate::Api for SceneTreeComponentApi {
    const NAME: *const i8 = TM_SCENE_TREE_COMPONENT_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_scene_tree_component_api)
    }
}
unsafe impl Send for SceneTreeComponentApi {}
unsafe impl Sync for SceneTreeComponentApi {}
pub struct TagComponentApi(pub *const tm_tag_component_api);

impl TagComponentApi {
    pub unsafe fn tag_assets(
        &self,
        tt: *mut tm_the_truth_o,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_tt_id_t {
        ((*self.0).tag_assets).unsafe_unwrap()(tt, ta)
    }

    pub unsafe fn add_tag(
        &self,
        tcm: *mut tm_tag_component_manager_o,
        e: tm_entity_t,
        tag: tm_strhash_t,
    ) {
        ((*self.0).add_tag).unsafe_unwrap()(tcm, e, tag)
    }

    pub unsafe fn add_tag_optional(
        &self,
        tcm: *mut tm_tag_component_manager_o,
        e: tm_entity_t,
        tag: tm_strhash_t,
    ) {
        ((*self.0).add_tag_optional).unsafe_unwrap()(tcm, e, tag)
    }

    pub unsafe fn remove_tag(
        &self,
        tcm: *mut tm_tag_component_manager_o,
        e: tm_entity_t,
        tag: tm_strhash_t,
    ) {
        ((*self.0).remove_tag).unsafe_unwrap()(tcm, e, tag)
    }

    pub unsafe fn has_tag(
        &self,
        tcm: *const tm_tag_component_manager_o,
        e: tm_entity_t,
        tag: tm_strhash_t,
    ) -> bool {
        ((*self.0).has_tag).unsafe_unwrap()(tcm, e, tag)
    }

    pub unsafe fn find_all(
        &self,
        tcm: *const tm_tag_component_manager_o,
        tag: tm_strhash_t,
        ta: *mut tm_temp_allocator_i,
    ) -> *mut tm_entity_t {
        ((*self.0).find_all).unsafe_unwrap()(tcm, tag, ta)
    }

    pub unsafe fn find_first(
        &self,
        tcm: *const tm_tag_component_manager_o,
        tag: tm_strhash_t,
    ) -> tm_entity_t {
        ((*self.0).find_first).unsafe_unwrap()(tcm, tag)
    }
}

impl crate::Api for TagComponentApi {
    const NAME: *const i8 = TM_TAG_COMPONENT_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_tag_component_api)
    }
}
unsafe impl Send for TagComponentApi {}
unsafe impl Sync for TagComponentApi {}
pub struct TransformComponentApi(pub *const tm_transform_component_api);

impl TransformComponentApi {
    pub unsafe fn get_position(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) -> tm_vec3_t {
        ((*self.0).get_position).unsafe_unwrap()(man, e)
    }

    pub unsafe fn get_rotation(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) -> tm_vec4_t {
        ((*self.0).get_rotation).unsafe_unwrap()(man, e)
    }

    pub unsafe fn get_scale(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) -> tm_vec3_t {
        ((*self.0).get_scale).unsafe_unwrap()(man, e)
    }

    pub unsafe fn get_transform(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) -> *const tm_transform_t {
        ((*self.0).get_transform).unsafe_unwrap()(man, e)
    }

    pub unsafe fn set_position(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        pos: tm_vec3_t,
    ) {
        ((*self.0).set_position).unsafe_unwrap()(man, e, pos)
    }

    pub unsafe fn set_rotation(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        rot: tm_vec4_t,
    ) {
        ((*self.0).set_rotation).unsafe_unwrap()(man, e, rot)
    }

    pub unsafe fn set_scale(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        scl: tm_vec3_t,
    ) {
        ((*self.0).set_scale).unsafe_unwrap()(man, e, scl)
    }

    pub unsafe fn set_transform(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        transform: *const tm_transform_t,
    ) {
        ((*self.0).set_transform).unsafe_unwrap()(man, e, transform)
    }

    pub unsafe fn get_local_position(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) -> tm_vec3_t {
        ((*self.0).get_local_position).unsafe_unwrap()(man, e)
    }

    pub unsafe fn get_local_rotation(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) -> tm_vec4_t {
        ((*self.0).get_local_rotation).unsafe_unwrap()(man, e)
    }

    pub unsafe fn get_local_scale(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) -> tm_vec3_t {
        ((*self.0).get_local_scale).unsafe_unwrap()(man, e)
    }

    pub unsafe fn get_local_transform(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) -> *const tm_transform_t {
        ((*self.0).get_local_transform).unsafe_unwrap()(man, e)
    }

    pub unsafe fn set_local_position(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        local_pos: tm_vec3_t,
    ) {
        ((*self.0).set_local_position).unsafe_unwrap()(man, e, local_pos)
    }

    pub unsafe fn set_local_rotation(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        local_rot: tm_vec4_t,
    ) {
        ((*self.0).set_local_rotation).unsafe_unwrap()(man, e, local_rot)
    }

    pub unsafe fn set_local_scale(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        local_scl: tm_vec3_t,
    ) {
        ((*self.0).set_local_scale).unsafe_unwrap()(man, e, local_scl)
    }

    pub unsafe fn set_local_transform(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        local_transform: *const tm_transform_t,
    ) {
        ((*self.0).set_local_transform).unsafe_unwrap()(man, e, local_transform)
    }

    pub unsafe fn update_world_transform(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) {
        ((*self.0).update_world_transform).unsafe_unwrap()(man, e)
    }

    pub unsafe fn update_local_transform(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
    ) {
        ((*self.0).update_local_transform).unsafe_unwrap()(man, e)
    }

    pub unsafe fn compute_world_transform(
        &self,
        world: *mut tm_transform_t,
        local: *const tm_transform_t,
        parent_world: *const tm_transform_t,
    ) -> *mut tm_transform_t {
        ((*self.0).compute_world_transform).unsafe_unwrap()(world, local, parent_world)
    }

    pub unsafe fn compute_local_transform(
        &self,
        local: *mut tm_transform_t,
        world: *const tm_transform_t,
        parent_world: *const tm_transform_t,
    ) -> *mut tm_transform_t {
        ((*self.0).compute_local_transform).unsafe_unwrap()(local, world, parent_world)
    }

    pub unsafe fn compute_parent_transform(
        &self,
        parent_world: *mut tm_transform_t,
        world: *const tm_transform_t,
        local: *const tm_transform_t,
    ) -> *mut tm_transform_t {
        ((*self.0).compute_parent_transform).unsafe_unwrap()(parent_world, world, local)
    }

    pub unsafe fn set_parent(
        &self,
        man: *mut tm_transform_component_manager_o,
        e: tm_entity_t,
        parent: tm_entity_t,
    ) {
        ((*self.0).set_parent).unsafe_unwrap()(man, e, parent)
    }
}

impl crate::Api for TransformComponentApi {
    const NAME: *const i8 = TM_TRANSFORM_COMPONENT_API_NAME as *const _ as *const i8;
    unsafe fn from_raw(raw: *const std::ffi::c_void) -> Self {
        Self(raw as *const tm_transform_component_api)
    }
}
unsafe impl Send for TransformComponentApi {}
unsafe impl Sync for TransformComponentApi {}
