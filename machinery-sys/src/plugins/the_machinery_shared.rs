/* automatically generated by rust-bindgen 0.59.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const TM_USE_STRHASH_TYPE: u32 = 1;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_vec2_t {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_vec3_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_vec4_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_mat44_t {
    pub xx: f32,
    pub xy: f32,
    pub xz: f32,
    pub xw: f32,
    pub yx: f32,
    pub yy: f32,
    pub yz: f32,
    pub yw: f32,
    pub zx: f32,
    pub zy: f32,
    pub zz: f32,
    pub zw: f32,
    pub wx: f32,
    pub wy: f32,
    pub wz: f32,
    pub ww: f32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_transform_t {
    pub pos: tm_vec3_t,
    pub rot: tm_vec4_t,
    pub scl: tm_vec3_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_rect_t {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_str_t {
    pub data: *const ::std::os::raw::c_char,
    pub size: u32,
    pub null_terminated: u32,
}
impl Default for tm_str_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_clock_o {
    pub opaque: u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_uuid_t {
    pub a: u64,
    pub b: u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_color_srgb_t {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_tt_type_t {
    pub u64_: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_tt_id_t {
    pub __bindgen_anon_1: tm_tt_id_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tm_tt_id_t__bindgen_ty_1 {
    pub u64_: u64,
    pub __bindgen_anon_1: tm_tt_id_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct tm_tt_id_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl tm_tt_id_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn type_(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn generation(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u64) }
    }
    #[inline]
    pub fn set_generation(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn index(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: u64,
        generation: u64,
        index: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let type_: u64 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let generation: u64 = unsafe { ::std::mem::transmute(generation) };
            generation as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let index: u64 = unsafe { ::std::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tm_tt_id_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tm_tt_id_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_tt_undo_scope_t {
    pub u64_: u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_strhash_t {
    pub u64_: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_entity_context_o {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_primitive_drawer_buffer_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_properties_ui_args_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_the_truth_o {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_ui_o {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_ui_style_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_undo_stack_i {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_camera_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_allocator_i {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_toolbar_i {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_temp_allocator_i {
    _unused: [u8; 0],
}
pub type tm_ci_editor_properties_ui_f = ::std::option::Option<
    unsafe extern "C" fn(
        args: *mut tm_properties_ui_args_t,
        item_rect: tm_rect_t,
        object: tm_tt_id_t,
        indent: u32,
    ) -> f32,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_ci_editor_ui_icon_i {
    pub ui_icon: ::std::option::Option<unsafe extern "C" fn() -> u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_ci_viewport_interact {
    pub tt: *mut tm_the_truth_o,
    pub entity_ctx: *mut tm_entity_context_o,
    pub entity: tm_tt_id_t,
    pub component: tm_tt_id_t,
    pub ui: *mut tm_ui_o,
    pub uistyle: *const tm_ui_style_t,
    pub primitive_buffer: *mut tm_primitive_drawer_buffer_t,
    pub vertex_buffer: *mut tm_primitive_drawer_buffer_t,
    pub allocator: *mut tm_allocator_i,
    pub camera: *const tm_camera_t,
    pub viewport_r: tm_rect_t,
    pub viewport_id: u64,
    pub tab_id: u64,
    pub undo_stack: *mut tm_undo_stack_i,
    pub active_tool_id: tm_strhash_t,
    pub move_settings: *mut tm_gizmo__move_settings_t,
    pub rotate_settings: *mut tm_gizmo__rotate_settings_t,
    pub scale_settings: *mut tm_gizmo__scale_settings_t,
    pub editor: *mut ::std::os::raw::c_void,
    pub set_selection: ::std::option::Option<
        unsafe extern "C" fn(editor: *mut ::std::os::raw::c_void, item_t: tm_tt_id_t),
    >,
}
impl Default for tm_ci_viewport_interact {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_ci_viewport_interact_result {
    pub hide_gizmo: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_ci_toolbar {
    pub editor: *mut ::std::os::raw::c_void,
    pub active_tool: ::std::option::Option<
        unsafe extern "C" fn(editor: *mut ::std::os::raw::c_void) -> tm_strhash_t,
    >,
    pub set_active_tool: ::std::option::Option<
        unsafe extern "C" fn(editor: *mut ::std::os::raw::c_void, id: tm_strhash_t),
    >,
}
impl Default for tm_ci_toolbar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_ci_editor_ui_i {
    pub disabled: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    pub category: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    pub icon_interface:
        ::std::option::Option<unsafe extern "C" fn() -> *mut tm_ci_editor_ui_icon_i>,
    pub gizmo_priority: f32,
    pub _padding_93: [::std::os::raw::c_char; 4usize],
    pub gizmo_get_transform: ::std::option::Option<
        unsafe extern "C" fn(
            tt: *const tm_the_truth_o,
            ctx: *mut tm_entity_context_o,
            entity: tm_tt_id_t,
            component: tm_tt_id_t,
            object: tm_tt_id_t,
            world: *mut tm_transform_t,
            local: *mut tm_transform_t,
        ) -> bool,
    >,
    pub gizmo_set_transform: ::std::option::Option<
        unsafe extern "C" fn(
            tt: *mut tm_the_truth_o,
            ctx: *mut tm_entity_context_o,
            entity: tm_tt_id_t,
            component: tm_tt_id_t,
            object: tm_tt_id_t,
            local: *const tm_transform_t,
            undo_scope: tm_tt_undo_scope_t,
        ),
    >,
    pub gizmo_duplicate: ::std::option::Option<
        unsafe extern "C" fn(
            tt: *mut tm_the_truth_o,
            ctx: *mut tm_entity_context_o,
            entity: tm_tt_id_t,
            component: tm_tt_id_t,
            object: tm_tt_id_t,
            undo_scope: tm_tt_undo_scope_t,
        ) -> tm_tt_id_t,
    >,
    pub override_properties: ::std::option::Option<
        unsafe extern "C" fn(
            tt: *mut tm_the_truth_o,
            other_component: tm_tt_id_t,
        ) -> tm_ci_editor_properties_ui_f,
    >,
    pub viewport_interact: ::std::option::Option<
        unsafe extern "C" fn(vi: *const tm_ci_viewport_interact) -> tm_ci_viewport_interact_result,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            tt: *mut tm_the_truth_o,
            type_: tm_tt_type_t,
            undo_scope: tm_tt_undo_scope_t,
        ) -> tm_tt_id_t,
    >,
    pub toolbars: ::std::option::Option<
        unsafe extern "C" fn(
            ci: *mut tm_ci_toolbar,
            ta: *mut tm_temp_allocator_i,
        ) -> *mut tm_toolbar_i,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_gizmo__move_settings_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_gizmo__rotate_settings_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm_gizmo__scale_settings_t {
    pub _address: u8,
}
