/* automatically generated by rust-bindgen 0.59.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const TM_USE_STRHASH_TYPE: u32 = 1;
pub const TM_API_REGISTRY_API_NAME: &'static [u8; 20usize] = b"tm_api_registry_api\0";
pub const TM_LOGGER_API_NAME: &'static [u8; 14usize] = b"tm_logger_api\0";
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_vec2_t {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_tm_vec2_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_vec2_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_vec2_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_vec2_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_vec2_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec2_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec2_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec2_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec2_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_vec3_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_tm_vec3_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_vec3_t>(),
        12usize,
        concat!("Size of: ", stringify!(tm_vec3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_vec3_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_vec3_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec3_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec3_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec3_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec3_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec3_t>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec3_t),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_vec4_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_tm_vec4_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_vec4_t>(),
        16usize,
        concat!("Size of: ", stringify!(tm_vec4_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_vec4_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_vec4_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec4_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec4_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec4_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec4_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec4_t>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec4_t),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec4_t>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec4_t),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_mat44_t {
    pub xx: f32,
    pub xy: f32,
    pub xz: f32,
    pub xw: f32,
    pub yx: f32,
    pub yy: f32,
    pub yz: f32,
    pub yw: f32,
    pub zx: f32,
    pub zy: f32,
    pub zz: f32,
    pub zw: f32,
    pub wx: f32,
    pub wy: f32,
    pub wz: f32,
    pub ww: f32,
}
#[test]
fn bindgen_test_layout_tm_mat44_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_mat44_t>(),
        64usize,
        concat!("Size of: ", stringify!(tm_mat44_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_mat44_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_mat44_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).xx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(xx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).xy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).xz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(xz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).xw as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(xw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).yx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(yx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).yy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(yy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).yz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(yz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).yw as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(yw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).zx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(zx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).zy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(zy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).zz as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(zz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).zw as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(zw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).wx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(wx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).wy as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(wy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).wz as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(wz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).ww as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(ww)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_transform_t {
    pub pos: tm_vec3_t,
    pub rot: tm_vec4_t,
    pub scl: tm_vec3_t,
}
#[test]
fn bindgen_test_layout_tm_transform_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_transform_t>(),
        40usize,
        concat!("Size of: ", stringify!(tm_transform_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_transform_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_transform_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_transform_t>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_transform_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_transform_t>())).rot as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_transform_t),
            "::",
            stringify!(rot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_transform_t>())).scl as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_transform_t),
            "::",
            stringify!(scl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_rect_t {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_tm_rect_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_rect_t>(),
        16usize,
        concat!("Size of: ", stringify!(tm_rect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_rect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_rect_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_rect_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_rect_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_rect_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_rect_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_rect_t>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_rect_t),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_rect_t>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_rect_t),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_str_t {
    pub data: *const ::std::os::raw::c_char,
    pub size: u32,
    pub null_terminated: u32,
}
#[test]
fn bindgen_test_layout_tm_str_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_str_t>(),
        16usize,
        concat!("Size of: ", stringify!(tm_str_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_str_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_str_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_str_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_str_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_str_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_str_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_str_t>())).null_terminated as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_str_t),
            "::",
            stringify!(null_terminated)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_clock_o {
    pub opaque: u64,
}
#[test]
fn bindgen_test_layout_tm_clock_o() {
    assert_eq!(
        ::std::mem::size_of::<tm_clock_o>(),
        8usize,
        concat!("Size of: ", stringify!(tm_clock_o))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_clock_o>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_clock_o))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_clock_o>())).opaque as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_clock_o),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_uuid_t {
    pub a: u64,
    pub b: u64,
}
#[test]
fn bindgen_test_layout_tm_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(tm_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_uuid_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_uuid_t>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_uuid_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_uuid_t>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_uuid_t),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_color_srgb_t {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
#[test]
fn bindgen_test_layout_tm_color_srgb_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_color_srgb_t>(),
        4usize,
        concat!("Size of: ", stringify!(tm_color_srgb_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_color_srgb_t>(),
        1usize,
        concat!("Alignment of ", stringify!(tm_color_srgb_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_color_srgb_t>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_color_srgb_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_color_srgb_t>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_color_srgb_t),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_color_srgb_t>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_color_srgb_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_color_srgb_t>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_color_srgb_t),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_tt_type_t {
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_tm_tt_type_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_type_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_tt_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_tt_type_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_tt_type_t>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_tt_type_t),
            "::",
            stringify!(u64_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_tt_id_t {
    pub __bindgen_anon_1: tm_tt_id_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tm_tt_id_t__bindgen_ty_1 {
    pub u64_: u64,
    pub __bindgen_anon_1: tm_tt_id_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct tm_tt_id_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_tm_tt_id_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_id_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(tm_tt_id_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_id_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(tm_tt_id_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl tm_tt_id_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn type_(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn generation(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u64) }
    }
    #[inline]
    pub fn set_generation(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn index(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: u64,
        generation: u64,
        index: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let type_: u64 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let generation: u64 = unsafe { ::std::mem::transmute(generation) };
            generation as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let index: u64 = unsafe { ::std::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_tm_tt_id_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_id_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(tm_tt_id_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_id_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_tt_id_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_tt_id_t__bindgen_ty_1>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_tt_id_t__bindgen_ty_1),
            "::",
            stringify!(u64_)
        )
    );
}
#[test]
fn bindgen_test_layout_tm_tt_id_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_id_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_tt_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_id_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_tt_id_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_tt_undo_scope_t {
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_tm_tt_undo_scope_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_undo_scope_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_tt_undo_scope_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_undo_scope_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_tt_undo_scope_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_tt_undo_scope_t>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_tt_undo_scope_t),
            "::",
            stringify!(u64_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_strhash_t {
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_tm_strhash_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_strhash_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_strhash_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_strhash_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_strhash_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_strhash_t>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_strhash_t),
            "::",
            stringify!(u64_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_allocator_i {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_api_registry_listener_i {
    pub ud: *mut ::std::os::raw::c_void,
    pub add_implementation: ::std::option::Option<
        unsafe extern "C" fn(
            ud: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            implementation: *const ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_tm_api_registry_listener_i() {
    assert_eq!(
        ::std::mem::size_of::<tm_api_registry_listener_i>(),
        16usize,
        concat!("Size of: ", stringify!(tm_api_registry_listener_i))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_api_registry_listener_i>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_api_registry_listener_i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_api_registry_listener_i>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_listener_i),
            "::",
            stringify!(ud)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_listener_i>())).add_implementation as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_listener_i),
            "::",
            stringify!(add_implementation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_api_registry_api {
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            api: *const ::std::os::raw::c_void,
            bytes: u32,
        ),
    >,
    pub remove: ::std::option::Option<unsafe extern "C" fn(api: *const ::std::os::raw::c_void)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
    >,
    pub get_optional: ::std::option::Option<
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
    >,
    pub add_implementation: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            implementation: *const ::std::os::raw::c_void,
        ),
    >,
    pub remove_implementation: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            implementation: *const ::std::os::raw::c_void,
        ),
    >,
    pub implementations: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            count: *mut u32,
        ) -> *mut *mut ::std::os::raw::c_void,
    >,
    pub add_listener:
        ::std::option::Option<unsafe extern "C" fn(listener: *const tm_api_registry_listener_i)>,
    pub static_variable: ::std::option::Option<
        unsafe extern "C" fn(
            id: tm_strhash_t,
            size: u32,
            file: *const ::std::os::raw::c_char,
            line: u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub log_missing_apis: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_tm_api_registry_api() {
    assert_eq!(
        ::std::mem::size_of::<tm_api_registry_api>(),
        80usize,
        concat!("Size of: ", stringify!(tm_api_registry_api))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_api_registry_api>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_api_registry_api))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_api_registry_api>())).set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_api_registry_api>())).remove as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_api_registry_api>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).get_optional as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(get_optional)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).add_implementation as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(add_implementation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).remove_implementation as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(remove_implementation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).implementations as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(implementations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).add_listener as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(add_listener)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).static_variable as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(static_variable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).log_missing_apis as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(log_missing_apis)
        )
    );
}
pub type tm_load_function =
    ::std::option::Option<unsafe extern "C" fn(reg: *mut tm_api_registry_api, load: bool)>;
pub const TM_LOG_TYPE_INFO: tm_log_type = 0;
pub const TM_LOG_TYPE_DEBUG: tm_log_type = 1;
pub const TM_LOG_TYPE_ERROR: tm_log_type = 2;
pub type tm_log_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_logger_o {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_logger_i {
    pub inst: *mut tm_logger_o,
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            inst: *mut tm_logger_o,
            log_type: tm_log_type,
            msg: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_tm_logger_i() {
    assert_eq!(
        ::std::mem::size_of::<tm_logger_i>(),
        16usize,
        concat!("Size of: ", stringify!(tm_logger_i))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_logger_i>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_logger_i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_i>())).inst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_i),
            "::",
            stringify!(inst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_i>())).log as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_i),
            "::",
            stringify!(log)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_logger_api {
    pub add_logger: ::std::option::Option<unsafe extern "C" fn(logger: *const tm_logger_i)>,
    pub remove_logger: ::std::option::Option<unsafe extern "C" fn(logger: *const tm_logger_i)>,
    pub print: ::std::option::Option<
        unsafe extern "C" fn(log_type: tm_log_type, msg: *const ::std::os::raw::c_char),
    >,
    pub printf: ::std::option::Option<
        unsafe extern "C" fn(
            log_type: tm_log_type,
            format: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub default_logger: *mut tm_logger_i,
}
#[test]
fn bindgen_test_layout_tm_logger_api() {
    assert_eq!(
        ::std::mem::size_of::<tm_logger_api>(),
        40usize,
        concat!("Size of: ", stringify!(tm_logger_api))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_logger_api>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_logger_api))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).add_logger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(add_logger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).remove_logger as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(remove_logger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).print as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).printf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(printf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).default_logger as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(default_logger)
        )
    );
}

// Code generated by tm_wasm build.rs

use unsafe_unwrap::UnsafeUnwrap;

impl tm_api_registry_api {
    pub const NAME: &'static str = "tm_api_registry_api";

    pub unsafe fn set (& self , name : & str , api : * const :: std :: os :: raw :: c_void , bytes : u32) {
        let name = std :: ffi :: CString :: new (name) . unwrap () ;
        (self . set) . unsafe_unwrap () (name . as_ptr () , api , bytes)
    }

    pub unsafe fn remove (& self , api : * const :: std :: os :: raw :: c_void) {
        (self . remove) . unsafe_unwrap () (api)
    }

    pub unsafe fn get (& self , name : & str) -> * mut :: std :: os :: raw :: c_void {
        let name = std :: ffi :: CString :: new (name) . unwrap () ;
        (self . get) . unsafe_unwrap () (name . as_ptr ())
    }

    pub unsafe fn get_optional (& self , name : & str) -> * mut :: std :: os :: raw :: c_void {
        let name = std :: ffi :: CString :: new (name) . unwrap () ;
        (self . get_optional) . unsafe_unwrap () (name . as_ptr ())
    }

    pub unsafe fn add_implementation (& self , name : & str , implementation : * const :: std :: os :: raw :: c_void) {
        let name = std :: ffi :: CString :: new (name) . unwrap () ;
        (self . add_implementation) . unsafe_unwrap () (name . as_ptr () , implementation)
    }

    pub unsafe fn remove_implementation (& self , name : & str , implementation : * const :: std :: os :: raw :: c_void) {
        let name = std :: ffi :: CString :: new (name) . unwrap () ;
        (self . remove_implementation) . unsafe_unwrap () (name . as_ptr () , implementation)
    }

    pub unsafe fn implementations (& self , name : & str , count : * mut u32) -> * mut * mut :: std :: os :: raw :: c_void {
        let name = std :: ffi :: CString :: new (name) . unwrap () ;
        (self . implementations) . unsafe_unwrap () (name . as_ptr () , count)
    }

    pub unsafe fn add_listener (& self , listener : * const tm_api_registry_listener_i) {
        (self . add_listener) . unsafe_unwrap () (listener)
    }

    pub unsafe fn static_variable (& self , id : tm_strhash_t , size : u32 , file : & str , line : u32) -> * mut :: std :: os :: raw :: c_void {
        let file = std :: ffi :: CString :: new (file) . unwrap () ;
        (self . static_variable) . unsafe_unwrap () (id , size , file . as_ptr () , line)
    }

    pub unsafe fn log_missing_apis (& self) {
        (self . log_missing_apis) . unsafe_unwrap () ()
    }

}

impl tm_logger_api {
    pub const NAME: &'static str = "tm_logger_api";

    pub unsafe fn add_logger (& self , logger : * const tm_logger_i) {
        (self . add_logger) . unsafe_unwrap () (logger)
    }

    pub unsafe fn remove_logger (& self , logger : * const tm_logger_i) {
        (self . remove_logger) . unsafe_unwrap () (logger)
    }

    pub unsafe fn print (& self , log_type : tm_log_type , msg : & str) {
        let msg = std :: ffi :: CString :: new (msg) . unwrap () ;
        (self . print) . unsafe_unwrap () (log_type , msg . as_ptr ())
    }

    pub unsafe fn printf (& self , log_type : tm_log_type , format : & str) -> :: std :: os :: raw :: c_int {
        let format = std :: ffi :: CString :: new (format) . unwrap () ;
        (self . printf) . unsafe_unwrap () (log_type , format . as_ptr ())
    }

}

