/* automatically generated by rust-bindgen 0.59.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const TM_USE_STRHASH_TYPE: u32 = 1;
pub const TM_API_REGISTRY_API_NAME: &'static [u8; 20usize] = b"tm_api_registry_api\0";
pub const TM_LOGGER_API_NAME: &'static [u8; 14usize] = b"tm_logger_api\0";
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " Represents a 2D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_vec2_t {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_tm_vec2_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_vec2_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_vec2_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_vec2_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_vec2_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec2_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec2_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec2_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec2_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " Represents a 3D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_vec3_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_tm_vec3_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_vec3_t>(),
        12usize,
        concat!("Size of: ", stringify!(tm_vec3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_vec3_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_vec3_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec3_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec3_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec3_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec3_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec3_t>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec3_t),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " Represents a 4D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_vec4_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_tm_vec4_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_vec4_t>(),
        16usize,
        concat!("Size of: ", stringify!(tm_vec4_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_vec4_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_vec4_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec4_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec4_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec4_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec4_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec4_t>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec4_t),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_vec4_t>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_vec4_t),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " Represents a 4x4 matrix."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_mat44_t {
    pub xx: f32,
    pub xy: f32,
    pub xz: f32,
    pub xw: f32,
    pub yx: f32,
    pub yy: f32,
    pub yz: f32,
    pub yw: f32,
    pub zx: f32,
    pub zy: f32,
    pub zz: f32,
    pub zw: f32,
    pub wx: f32,
    pub wy: f32,
    pub wz: f32,
    pub ww: f32,
}
#[test]
fn bindgen_test_layout_tm_mat44_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_mat44_t>(),
        64usize,
        concat!("Size of: ", stringify!(tm_mat44_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_mat44_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_mat44_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).xx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(xx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).xy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).xz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(xz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).xw as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(xw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).yx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(yx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).yy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(yy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).yz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(yz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).yw as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(yw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).zx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(zx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).zy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(zy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).zz as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(zz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).zw as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(zw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).wx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(wx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).wy as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(wy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).wz as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(wz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_mat44_t>())).ww as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_mat44_t),
            "::",
            stringify!(ww)
        )
    );
}
#[doc = " Represents a transform in TRS form."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_transform_t {
    pub pos: tm_vec3_t,
    pub rot: tm_vec4_t,
    pub scl: tm_vec3_t,
}
#[test]
fn bindgen_test_layout_tm_transform_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_transform_t>(),
        40usize,
        concat!("Size of: ", stringify!(tm_transform_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_transform_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_transform_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_transform_t>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_transform_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_transform_t>())).rot as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_transform_t),
            "::",
            stringify!(rot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_transform_t>())).scl as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_transform_t),
            "::",
            stringify!(scl)
        )
    );
}
#[doc = " Represents a rectangle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_rect_t {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_tm_rect_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_rect_t>(),
        16usize,
        concat!("Size of: ", stringify!(tm_rect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_rect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tm_rect_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_rect_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_rect_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_rect_t>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_rect_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_rect_t>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_rect_t),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_rect_t>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_rect_t),
            "::",
            stringify!(h)
        )
    );
}
#[doc = " Used to represent a string slice with pointer and length."]
#[doc = ""]
#[doc = " This lets you reason about parts of a string, which you are not able to do with standard"]
#[doc = " NULL-terminated strings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_str_t {
    #[doc = " Pointer to string bytes."]
    pub data: *const ::std::os::raw::c_char,
    #[doc = " Length of the string."]
    pub size: u32,
    #[doc = " If set to *true*, indicates that there is an allocated NULL-byte after the string data. I.e."]
    #[doc = " `data[size] == 0`. This means that `data` can be used immediately as a C string without"]
    #[doc = " needing to copy it to a separate memory area."]
    #[doc = ""]
    #[doc = " If *false*, there may or may not be a NULL-byte at the end of the string and accessing"]
    #[doc = " `data[size]` may cause an access violation, so if you want to use it as a C-string you have"]
    #[doc = " to copy it to a new memory area and append a NULL byte."]
    #[doc = ""]
    #[doc = " Note that the NULL-byte is never included in the `size`."]
    pub null_terminated: u32,
}
#[test]
fn bindgen_test_layout_tm_str_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_str_t>(),
        16usize,
        concat!("Size of: ", stringify!(tm_str_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_str_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_str_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_str_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_str_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_str_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_str_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_str_t>())).null_terminated as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_str_t),
            "::",
            stringify!(null_terminated)
        )
    );
}
#[doc = " Represents a time from the system clock."]
#[doc = ""]
#[doc = " You can assume the clock to be monotonically increasing, i.e. a larger `opaque` value represents"]
#[doc = " a later time, but you shouldn't assume anything else about what the `opaque` value represents or"]
#[doc = " the resolution of the timer. Instead, use [[tm_os_time_api->delta()]] to convert elapsed time to"]
#[doc = " seconds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_clock_o {
    pub opaque: u64,
}
#[test]
fn bindgen_test_layout_tm_clock_o() {
    assert_eq!(
        ::std::mem::size_of::<tm_clock_o>(),
        8usize,
        concat!("Size of: ", stringify!(tm_clock_o))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_clock_o>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_clock_o))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_clock_o>())).opaque as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_clock_o),
            "::",
            stringify!(opaque)
        )
    );
}
#[doc = " Represents a unique 128-bit identifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_uuid_t {
    pub a: u64,
    pub b: u64,
}
#[test]
fn bindgen_test_layout_tm_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(tm_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_uuid_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_uuid_t>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_uuid_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_uuid_t>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_uuid_t),
            "::",
            stringify!(b)
        )
    );
}
#[doc = " Represents an 8-bit per channel RGBA color in sRGB color space (Note: alpha is always linear.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_color_srgb_t {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
#[test]
fn bindgen_test_layout_tm_color_srgb_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_color_srgb_t>(),
        4usize,
        concat!("Size of: ", stringify!(tm_color_srgb_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_color_srgb_t>(),
        1usize,
        concat!("Alignment of ", stringify!(tm_color_srgb_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_color_srgb_t>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_color_srgb_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_color_srgb_t>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_color_srgb_t),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_color_srgb_t>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_color_srgb_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_color_srgb_t>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_color_srgb_t),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " Type representing a type in The Truth."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_tt_type_t {
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_tm_tt_type_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_type_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_tt_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_tt_type_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_tt_type_t>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_tt_type_t),
            "::",
            stringify!(u64_)
        )
    );
}
#[doc = " ID representing an object in The Truth."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm_tt_id_t {
    pub __bindgen_anon_1: tm_tt_id_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tm_tt_id_t__bindgen_ty_1 {
    #[doc = " Used for comparing objects or storing them in hash tables."]
    pub u64_: u64,
    pub __bindgen_anon_1: tm_tt_id_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct tm_tt_id_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_tm_tt_id_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_id_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(tm_tt_id_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_id_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(tm_tt_id_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl tm_tt_id_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn type_(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn generation(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u64) }
    }
    #[inline]
    pub fn set_generation(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn index(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: u64,
        generation: u64,
        index: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let type_: u64 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let generation: u64 = unsafe { ::std::mem::transmute(generation) };
            generation as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let index: u64 = unsafe { ::std::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_tm_tt_id_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_id_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(tm_tt_id_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_id_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_tt_id_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_tt_id_t__bindgen_ty_1>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_tt_id_t__bindgen_ty_1),
            "::",
            stringify!(u64_)
        )
    );
}
#[test]
fn bindgen_test_layout_tm_tt_id_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_id_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_tt_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_id_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_tt_id_t))
    );
}
#[doc = " Type representing an undo scope in The Truth."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_tt_undo_scope_t {
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_tm_tt_undo_scope_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_tt_undo_scope_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_tt_undo_scope_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_tt_undo_scope_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_tt_undo_scope_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_tt_undo_scope_t>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_tt_undo_scope_t),
            "::",
            stringify!(u64_)
        )
    );
}
#[doc = " Type-safe representation of a hashed string."]
#[doc = ""]
#[doc = " !!! WARNING: WARNING"]
#[doc = "     In Visual Studio, string hashes won't use this string type, instead"]
#[doc = "     [[tm_strhash_t]] will be typedefed to `uint64_t`. The reason for this is that the"]
#[doc = "     [[TM_STATIC_HASH()]] macro is not seen as a constant by the MSVC compiler and thus using it"]
#[doc = "     to initialize global variables yields the"]
#[doc = "     [C2099](https://docs.microsoft.com/en-us/cpp/error-messages/compiler-errors-1/compiler-error-c2099?view=msvc-160)"]
#[doc = "     compiler error."]
#[doc = ""]
#[doc = "     This means that the type safety of string hashes won't be checked when compiling with MSVC."]
#[doc = "     Make sure you build your code under clang too, with `tmbuild --clang` to check the type"]
#[doc = "     safety of string hashes. Also, always use the macros [[TM_STRHASH()]] and"]
#[doc = "     [[TM_STRHASH_U64()]] to convert between [[tm_strhash_t]] and `uint64_t`. This ensures that"]
#[doc = "     the conversions work on all platforms."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_strhash_t {
    pub u64_: u64,
}
#[test]
fn bindgen_test_layout_tm_strhash_t() {
    assert_eq!(
        ::std::mem::size_of::<tm_strhash_t>(),
        8usize,
        concat!("Size of: ", stringify!(tm_strhash_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_strhash_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_strhash_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_strhash_t>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_strhash_t),
            "::",
            stringify!(u64_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_allocator_i {
    _unused: [u8; 0],
}
#[doc = " Listener for receiving information about changes to the API registry. Use [[add_listener()]] to add"]
#[doc = " a listener to the API registry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_api_registry_listener_i {
    pub ud: *mut ::std::os::raw::c_void,
    #[doc = " Called when an implementation was added for the interface `name`."]
    pub add_implementation: ::std::option::Option<
        unsafe extern "C" fn(
            ud: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
            implementation: *const ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_tm_api_registry_listener_i() {
    assert_eq!(
        ::std::mem::size_of::<tm_api_registry_listener_i>(),
        16usize,
        concat!("Size of: ", stringify!(tm_api_registry_listener_i))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_api_registry_listener_i>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_api_registry_listener_i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_api_registry_listener_i>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_listener_i),
            "::",
            stringify!(ud)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_listener_i>())).add_implementation as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_listener_i),
            "::",
            stringify!(add_implementation)
        )
    );
}
#[doc = " Global registry that keeps track of loaded APIs and interface implementations."]
#[doc = ""]
#[doc = " The difference between an API and an interface is that APIs only have a single implementation,"]
#[doc = " whereas interfaces can have many implementations."]
#[doc = ""]
#[doc = " For example the OS API [[tm_os_api]] provides the implementation of OS functions to access files,"]
#[doc = " memory, etc. It only has a single implementation for each supported platform, and it is this"]
#[doc = " implementation you call upon to perform OS functions."]
#[doc = ""]
#[doc = " In contrast, each module that supports unit tests implements the [[tm_unit_test_i]] interface. By"]
#[doc = " querying for the [[tm_unit_test_i]] interface, you can enumerate all these implementations and run"]
#[doc = " all the unit tests."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_api_registry_api {
    #[doc = " Sets an API in the registry. `name` is the name of the API that is implemented and `api` is a"]
    #[doc = " pointer to the struct of function pointers defining the API. `bytes` is the size of this"]
    #[doc = " struct."]
    #[doc = ""]
    #[doc = " APIs can be implemented only once. If you call [[set()]] again, it replaces the previous API"]
    #[doc = " pointers. This can be used to implement hot-reload of APIs."]
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            api: *const ::std::os::raw::c_void,
            bytes: u32,
        ),
    >,
    #[doc = " Removes `API` if it is in use."]
    pub remove: ::std::option::Option<unsafe extern "C" fn(api: *const ::std::os::raw::c_void)>,
    #[doc = " Gets a pointer to the API implementing the API `name`."]
    #[doc = ""]
    #[doc = " `get(name)` is guaranteed to always return the same pointer, throughout the lifetime of an"]
    #[doc = " application (whether `set(name)` has been called zero, one or multiple times). It returns a"]
    #[doc = " pointer to internal API registry memory and the actual API pointers are copied to this memory"]
    #[doc = " by [[set()]]."]
    #[doc = ""]
    #[doc = " On hot-reload these function pointers will be overwritten, but this is transparent to users"]
    #[doc = " of the API. They can continue to use the same interface pointer and will call the new methods"]
    #[doc = " automatically. (If they have cached the function pointers in the API locally, they will keep"]
    #[doc = " calling the old methods.)"]
    #[doc = ""]
    #[doc = " Calling [[get()]] on an API that hasn't been loaded yet will return a struct full of NULL"]
    #[doc = " function pointers. When the API is loaded (and calls [[set()]]), these NULL pointers will be"]
    #[doc = " replaced by the real function pointers of the API."]
    #[doc = ""]
    #[doc = " To test whether an API has been loaded, you can test if it contains NULL function pointers or"]
    #[doc = " not."]
    pub get: ::std::option::Option<
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " As [[get()]], but indicates that this is an optional API, i.e. we will be able to continue to"]
    #[doc = " run even if this API is not available."]
    pub get_optional: ::std::option::Option<
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Adds an implementation of the interface named `name`."]
    pub add_implementation: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            implementation: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Removes the specified implementation of the interface `name`."]
    pub remove_implementation: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            implementation: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Returns an array of all the implementations implementing the interface `name`. The size of"]
    #[doc = " the array is returned in `count`."]
    #[doc = ""]
    #[doc = " !!! TODO: API-REVIEW"]
    #[doc = "     This function is kind of annoying to call, either improve this interface or provide an"]
    #[doc = "     alternative one."]
    pub implementations: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            count: *mut u32,
        ) -> *mut *mut ::std::os::raw::c_void,
    >,
    #[doc = " Adds a listener that will be called with changes to the api_registry. Currently, only an"]
    #[doc = " `add_implementation` callback is provided."]
    pub add_listener:
        ::std::option::Option<unsafe extern "C" fn(listener: *const tm_api_registry_listener_i)>,
    #[doc = " Returns a pointer to a static variable that survives plugin reloads. `id` is a unique"]
    #[doc = " identifier for the variable and `size` its size in bytes. The first time this function is"]
    #[doc = " called, the variable will be zero-initialized."]
    #[doc = ""]
    #[doc = " Use of static variables in DLLs can be problematic, because when the DLL is reloaded, the"]
    #[doc = " new instance of the DLL will get a new freshly initialized static variable, losing whatever"]
    #[doc = " content the variable had before reload. By using [[static_variable()]] instead, the variable"]
    #[doc = " data is saved in permanent memory."]
    #[doc = ""]
    #[doc = " Instead of this:"]
    #[doc = ""]
    #[doc = " ~~~c dont"]
    #[doc = " uint64_t count;"]
    #[doc = ""]
    #[doc = " void f()"]
    #[doc = " {"]
    #[doc = "     ++count;"]
    #[doc = " }"]
    #[doc = " ~~~"]
    #[doc = ""]
    #[doc = " You would do this:"]
    #[doc = ""]
    #[doc = " ~~~c"]
    #[doc = " uint64_t *count_ptr;"]
    #[doc = ""]
    #[doc = " void load(struct tm_api_registry_api *reg)"]
    #[doc = " {"]
    #[doc = "     count_ptr = (uint64_t *)reg->static_variable(TM_STATIC_HASH(\"my_count\", 0xa287d4b3ec9c2109ULL),"]
    #[doc = "         sizeof(uint64_t), __FILE__, __LINE__);"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " void f()"]
    #[doc = " {"]
    #[doc = "     ++*count_ptr;"]
    #[doc = " }"]
    #[doc = " ~~~"]
    pub static_variable: ::std::option::Option<
        unsafe extern "C" fn(
            id: tm_strhash_t,
            size: u32,
            file: *const ::std::os::raw::c_char,
            line: u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Print a log message about APIs that were requested with [[get()]] but were never found."]
    pub log_missing_apis: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_tm_api_registry_api() {
    assert_eq!(
        ::std::mem::size_of::<tm_api_registry_api>(),
        80usize,
        concat!("Size of: ", stringify!(tm_api_registry_api))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_api_registry_api>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_api_registry_api))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_api_registry_api>())).set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_api_registry_api>())).remove as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_api_registry_api>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).get_optional as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(get_optional)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).add_implementation as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(add_implementation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).remove_implementation as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(remove_implementation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).implementations as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(implementations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).add_listener as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(add_listener)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).static_variable as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(static_variable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm_api_registry_api>())).log_missing_apis as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_api_registry_api),
            "::",
            stringify!(log_missing_apis)
        )
    );
}
#[doc = " Function type for loading plugins or subparts of plugins."]
pub type tm_load_function =
    ::std::option::Option<unsafe extern "C" fn(reg: *mut tm_api_registry_api, load: bool)>;
#[doc = " Used for informational messages and command output."]
pub const TM_LOG_TYPE_INFO: tm_log_type = 0;
#[doc = " Used for debug prints when trying to diagnose a problem. Once the problem is fixed, all debug"]
#[doc = " output should be removed."]
pub const TM_LOG_TYPE_DEBUG: tm_log_type = 1;
#[doc = " Used for error messages. This should only be used for actual errors and it should be possible"]
#[doc = " for the user to fix the error and make the error message go away."]
pub const TM_LOG_TYPE_ERROR: tm_log_type = 2;
#[doc = " Specifies the type of a log message."]
pub type tm_log_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_logger_o {
    _unused: [u8; 0],
}
#[doc = " Interface for loggers. A logger receives log messages and does something"]
#[doc = " with them -- prints to a console, dumps to a file, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_logger_i {
    pub inst: *mut tm_logger_o,
    #[doc = " Logs the `msg` of type `log_type` to this logger."]
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            inst: *mut tm_logger_o,
            log_type: tm_log_type,
            msg: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_tm_logger_i() {
    assert_eq!(
        ::std::mem::size_of::<tm_logger_i>(),
        16usize,
        concat!("Size of: ", stringify!(tm_logger_i))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_logger_i>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_logger_i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_i>())).inst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_i),
            "::",
            stringify!(inst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_i>())).log as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_i),
            "::",
            stringify!(log)
        )
    );
}
#[doc = " Manages a list of active loggers. You can register more loggers to add more backend outputs for"]
#[doc = " log messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_logger_api {
    #[doc = " Adds a new logger to the registry."]
    pub add_logger: ::std::option::Option<unsafe extern "C" fn(logger: *const tm_logger_i)>,
    #[doc = " Removes a previously added logger from the registry."]
    pub remove_logger: ::std::option::Option<unsafe extern "C" fn(logger: *const tm_logger_i)>,
    #[doc = " Sends a log message to all registered loggers."]
    pub print: ::std::option::Option<
        unsafe extern "C" fn(log_type: tm_log_type, msg: *const ::std::os::raw::c_char),
    >,
    #[doc = " Convenience function for sending a formatted string message to all registered loggers."]
    pub printf: ::std::option::Option<
        unsafe extern "C" fn(
            log_type: tm_log_type,
            format: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A default logger that will print log messages using `printf(...)`."]
    #[doc = ""]
    #[doc = " On Windows, these messages are also printed using `OutputDebugString()` so they appear in"]
    #[doc = " Visual Studios log console."]
    #[doc = ""]
    #[doc = " Note that this logger is automatically added. You need to explicitly remove it, if you don't want to use it."]
    pub default_logger: *mut tm_logger_i,
}
#[test]
fn bindgen_test_layout_tm_logger_api() {
    assert_eq!(
        ::std::mem::size_of::<tm_logger_api>(),
        40usize,
        concat!("Size of: ", stringify!(tm_logger_api))
    );
    assert_eq!(
        ::std::mem::align_of::<tm_logger_api>(),
        8usize,
        concat!("Alignment of ", stringify!(tm_logger_api))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).add_logger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(add_logger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).remove_logger as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(remove_logger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).print as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).printf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(printf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm_logger_api>())).default_logger as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm_logger_api),
            "::",
            stringify!(default_logger)
        )
    );
}
