use std::{env, fs, path::Path};

use proc_macro2::TokenStream;
use quote::quote;
use syn::{GenericArgument, Item, ItemStruct, PathArguments, Type, TypeBareFn};

fn main() {
    let out_path = Path::new("./src/foundation.rs");

    // Only bindgen if the file doesn't exist already
    //if out_path.exists() {
    //    return;
    //}

    let mut generated_text = generate_bindings();
    generate_extensions(&mut generated_text);

    // Write the code out to file
    fs::write(out_path, generated_text).unwrap();
}

fn generate_bindings() -> String {
    let tm_sdk = env::var("TM_SDK_DIR").expect("TM_SDK_DIR environment variable wasn't set");

    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        // Tell it where to find the includes for machinery
        .clang_arg(format!("-I{}/headers", tm_sdk))
        .parse_callbacks(Box::new(ParseCallbacks))
        .prepend_enum_name(false)
        .generate()
        .expect("Unable to generate bindings");

    // Write the bindings
    let mut generated = Vec::new();
    bindings
        .write(Box::new(&mut generated))
        .expect("Couldn't write bindings!");
    String::from_utf8(generated).unwrap()
}

#[derive(Debug)]
pub struct ParseCallbacks;

impl bindgen::callbacks::ParseCallbacks for ParseCallbacks {
    fn include_file(&self, filename: &str) {
        println!("cargo:rerun-if-changed={}", filename);
    }
}

fn generate_extensions(src: &mut String) {
    // Scan the generated code for additional types and append them
    src.push_str("\n// Code generated by tm_wasm build.rs\n\n");
    src.push_str("use unsafe_unwrap::UnsafeUnwrap;\n\n");
    let file = syn::parse_file(&src).unwrap();

    for item in file.items {
        if let Item::Struct(item) = item {
            let name = item.ident.to_string();

            // Skip anything that isn't an API
            if !name.ends_with("_api") {
                continue;
            }

            generate_api(src, item);
        }
    }
}

fn generate_api(src: &mut String, item: ItemStruct) {
    src.push_str(&format!("impl {} {{\n", item.ident));

    // Associated name
    src.push_str(&format!(
        "    pub const NAME: &'static str = \"{}\";\n\n",
        item.ident,
    ));

    for field in item.fields {
        let path_type = if let Type::Path(path_type) = field.ty {
            path_type
        } else {
            continue;
        };

        // Extract the type
        let segment = path_type.path.segments.last().unwrap();
        if segment.ident != "Option" {
            // Skip non-options, they're not what we're looking for
            continue;
        }

        let arguments = if let PathArguments::AngleBracketed(ref arguments) = segment.arguments {
            arguments
        } else {
            continue;
        };

        let type_arg = if let GenericArgument::Type(ref type_arg) = arguments.args[0] {
            type_arg
        } else {
            continue;
        };

        let fn_type = if let Type::BareFn(fn_type) = type_arg {
            fn_type
        } else {
            continue;
        };

        // Convert the parameters
        let (in_args, conversions, out_args) = generate_in_args(fn_type);
        let in_args: Vec<_> = vec![quote!(&self)].into_iter().chain(in_args).collect();

        let name = field.ident.unwrap();
        let output = &fn_type.output;
        let function = quote! {
            pub unsafe fn #name(#(#in_args),*) #output
        };

        src.push_str(&format!("    {} {{\n", function));

        // Perform conversions
        for conversion in conversions {
            src.push_str(&format!("        {}\n", conversion));
        }

        // Call into the field
        let call = quote! {
            (self.#name).unsafe_unwrap()(#(#out_args),*)
        };
        src.push_str(&format!("        {}\n", call));

        src.push_str("    }\n\n");
    }

    src.push_str("}\n\n");
}

fn generate_in_args<'a>(
    fn_type: &'a TypeBareFn,
) -> (Vec<TokenStream>, Vec<TokenStream>, Vec<TokenStream>) {
    let mut in_args = Vec::new();
    let mut conversions = Vec::new();
    let mut out_args = Vec::new();

    for input in &fn_type.inputs {
        let name = &input.name.as_ref().unwrap().0;

        let raw_ty = &input.ty;
        let mut in_ty = quote! {#raw_ty};
        let mut out_arg = quote!(#name);

        // If this is a type we can convert, add a conversion
        if let Type::Ptr(ptr) = &input.ty {
            if let Type::Path(ty_path) = ptr.elem.as_ref() {
                if ty_path.path.segments.last().unwrap().ident == "c_char" {
                    let conversion = quote! {
                        let #name = std::ffi::CString::new(#name).unwrap();
                    };
                    conversions.push(conversion);

                    in_ty = quote! { &str };
                    out_arg = quote! { #name.as_ptr() };
                }
            }
        }

        in_args.push(quote!(#name: #in_ty));
        out_args.push(out_arg);
    }

    (in_args, conversions, out_args)
}
